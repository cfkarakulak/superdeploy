# Caddyfile for {{ project_name }}
# Auto-generated by SuperDeploy

{
    # Global options
    email {{ EMAIL | default('admin@example.com') }}
    
    # Admin API
    admin :{{ ADMIN_PORT | default('2019') }}
    
    # Enable metrics for Prometheus
    servers {
        metrics
    }
    
    # TLS mode: auto (Let's Encrypt)
    # For production use with real domains
}

# Main configuration - subdomain-based routing
# Each app on this VM gets its own domain block

# Port 80 catch-all with path-based routing (when no domains configured)
# Fallback for development/testing with IP-only access
{% set has_any_domain = namespace(value=false) %}
{% if apps is defined %}
{% for app_name, app_config in apps.items() %}
{% if app_config.get('vm') == vm_role and app_config.get('domain') %}
{% set has_any_domain.value = true %}
{% endif %}
{% endfor %}
{% endif %}

{% if not has_any_domain.value and apps is defined %}
:80 {
{% for app_name, app_config in apps.items() %}
{% if app_config.get('vm') == vm_role and app_config.get('port') %}
    # {{ app_name }} routing
    handle /{{ app_name }}* {
        reverse_proxy {{ app_name }}-web:{{ app_config.get('port', 8000) }}
    }
{% endif %}
{% endfor %}
    
    # Default: route to first web app (storefront or first available)
{% for app_name, app_config in apps.items() %}
{% if app_config.get('vm') == vm_role and app_config.get('port') and 'storefront' in app_name %}
    handle {
        reverse_proxy {{ app_name }}-web:{{ app_config.get('port', 3000) }}
    }
{% endif %}
{% endfor %}
}
{% endif %}

{% if apps is defined %}
{% for app_name, app_config in apps.items() %}
{% if app_config.get('vm') == vm_role and app_config.get('port') %}

# {{ app_name }} service
{% if app_config.get('domain') %}
# Domain-based routing (production)
{{ app_config.get('domain') }} {
    # Enable compression
    encode gzip zstd
    
    # Logging
    log {
        output file /data/logs/{{ app_name }}-access.log {
            roll_size 100mb
            roll_keep 5
        }
        format json
    }
    
    # Health check endpoint
    handle /health {
        respond "OK" 200
    }
    
    # Proxy to {{ app_name }}-web service (process-based architecture)
    reverse_proxy {{ app_name }}-web:{{ app_config.get('port', 8000) }} {
        # Docker Compose service discovery handles load balancing across replicas
        lb_policy round_robin
        lb_try_duration 5s
        lb_try_interval 250ms
        
        # Standard proxy headers
        header_up Host {host}
        header_up X-Real-IP {remote_host}
        header_up X-Forwarded-For {remote_host}
        header_up X-Forwarded-Proto {scheme}
        
        # Health checks (optional - Docker already tracks container health)
        health_uri /health
        health_interval 10s
        health_timeout 5s
        health_status 2xx
    }
}
{% else %}
# Port-based routing (development - no domain yet)
:{{ app_config.get('port', 8000) }} {
    # Simple pass-through to app-web service (load balanced if replicas > 1)
    reverse_proxy {{ app_name }}-web:{{ app_config.get('port', 8000) }}
}
{% endif %}
{% endif %}
{% endfor %}
{% endif %}

# Metrics endpoint (Prometheus)
:{{ ADMIN_PORT | default('2019') }} {
    metrics /metrics
}
