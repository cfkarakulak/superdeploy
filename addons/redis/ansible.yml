---
# Redis Addon Deployment Tasks

- name: Create {{ addon_name }} directories
  file:
    path: "{{ item }}"
    state: directory
    owner: "{{ superdeploy_user }}"
    group: "{{ superdeploy_group | default(superdeploy_user) }}"
    mode: '0755'
  loop:
    - "{{ addon_base_path }}/{{ addon_name }}"
    - "{{ addon_base_path }}/{{ addon_name }}/data"

# Note: docker-compose.yml is already rendered by orchestration/addon-deployer/tasks/render-templates.yml
# This keeps the deployment logic clean and focused on service-specific tasks

- name: Render {{ addon_name }} environment file
  template:
    src: "{{ addon_path }}/templates/redis.env.j2"
    dest: "{{ addon_base_path }}/{{ addon_name }}/.env"
    owner: "{{ superdeploy_user }}"
    group: "{{ superdeploy_group | default(superdeploy_user) }}"
    mode: '0600'
  when: addon_path is defined and addon_path | length > 0

- name: CLEANUP - Stop and remove all {{ addon_name }} containers (aggressive)
  shell: |
    set -e
    FILTER_NAME="{{ project_name }}-{{ addon_name }}"
    
    # Find all containers
    CONTAINERS=$(docker ps -aq --filter "name=${FILTER_NAME}" 2>/dev/null || echo "")
    
    # If containers found, stop and remove them
    if [ -n "$CONTAINERS" ]; then
      echo "Found containers: $CONTAINERS"
      docker stop $CONTAINERS 2>/dev/null || true
      docker rm -f $CONTAINERS 2>/dev/null || true
    fi
    
    # Final cleanup by name
    docker rm -f "${FILTER_NAME}" 2>/dev/null || true
    
    # Verify cleanup
    REMAINING=$(docker ps -aq --filter "name=${FILTER_NAME}" 2>/dev/null || echo "")
    if [ -n "$REMAINING" ]; then
      echo "Warning: Containers still exist: $REMAINING"
      exit 1
    fi
    
    echo "All {{ addon_name }} containers cleaned up"
  become_user: "{{ superdeploy_user }}"
  register: cleanup_result
  changed_when: false
  failed_when: cleanup_result.rc != 0

- name: Start {{ addon_name }} services (fresh deployment)
  community.docker.docker_compose_v2:
    project_src: "{{ addon_base_path }}/{{ addon_name }}"
    state: present
    pull: "always"
    recreate: "always"
    remove_orphans: true
  become_user: "{{ superdeploy_user }}"
  register: redis_compose_result

- name: Wait for {{ addon_name }} to be ready
  wait_for:
    host: localhost
    port: "{{ REDIS_PORT | default(6379) }}"
    delay: 5
    timeout: 60
    state: started
  when: redis_compose_result.changed

- name: Verify {{ addon_name }} is accessible
  shell: |
    docker exec {{ project_name }}-{{ addon_name }} redis-cli --no-auth-warning -a {{ REDIS_PASSWORD }} ping
  register: redis_health_check
  until: redis_health_check.rc == 0 and redis_health_check.stdout == "PONG"
  retries: 5
  delay: 2
  changed_when: false
  failed_when: redis_health_check.rc != 0

- name: Verify {{ addon_name }} connection
  shell: |
    docker exec {{ project_name }}-{{ addon_name }} redis-cli --no-auth-warning -a {{ REDIS_PASSWORD }} INFO server | grep redis_version
  register: redis_info
  changed_when: false
  failed_when: false

- name: Display {{ addon_name }} deployment status
  debug:
    msg: "Redis is ready - {{ redis_info.stdout | trim }}"
  when: redis_info.rc == 0
