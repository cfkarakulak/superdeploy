---
# Mongodb Addon Instance Deployment Tasks
# Instance: {{ instance_full_name }}

- name: Create {{ instance_name }} directories
  file:
    path: "{{ item }}"
    state: directory
    owner: "{{ superdeploy_user }}"
    group: "{{ superdeploy_group | default(superdeploy_user) }}"
    mode: '0755'
  loop:
    - "{{ addons_base_path }}/{{ instance_name }}"
    - "{{ addons_base_path }}/{{ instance_name }}/data"
    - "{{ addons_base_path }}/{{ instance_name }}/config"

# Note: docker-compose.yml is already rendered by orchestration/addon-deployer/tasks/render-templates.yml
# This keeps the deployment logic clean and focused on service-specific tasks

- name: Render {{ instance_name }} environment file
  template:
    src: "{{ addon_path }}/templates/mongodb.env.j2"
    dest: "{{ addons_base_path }}/{{ instance_name }}/.env"
    owner: "{{ superdeploy_user }}"
    group: "{{ superdeploy_group | default(superdeploy_user) }}"
    mode: '0600'
  when: addon_path is defined and addon_path | length > 0

- name: Deploy {{ instance_name }} with intelligent cleanup
  shell:
    cmd: |
      set -e
      cd "${ADDON_BASE_PATH}/${ADDON_NAME}"
      
      echo "Starting cleanup for ${CONTAINER_NAME}..."
      
      # Phase 1: Stop via Docker Compose (graceful shutdown with remove)
      echo "Phase 1: Stopping containers via Docker Compose..."
      docker compose --project-name "${CONTAINER_NAME}" down --timeout 30 2>&1 || true
      
      # Phase 2: Wait for Docker daemon to sync
      echo "Phase 2: Waiting for Docker daemon to sync..."
      sleep 10
      
      # Force sync by listing containers
      docker ps -a > /dev/null 2>&1
      
      # Phase 3: Force remove any remaining containers by exact name or prefix
      echo "Phase 3: Force removing any remaining containers..."
      # Get all container names matching our pattern and filter for exact/prefix match
      ALL_NAMES=$(docker ps -a --filter "name=${CONTAINER_NAME}" --format '{{ '{{' }}.Names{{ '}}' }}' 2>/dev/null || true)
      EXACT_CONTAINER=""
      PREFIX_CONTAINERS=""
      
      for name in $ALL_NAMES; do
        if [ "$name" = "${CONTAINER_NAME}" ]; then
          # Exact match
          EXACT_CONTAINER=$(docker ps -aq --filter "name=${name}" 2>/dev/null || true)
        elif [[ "$name" == ${CONTAINER_NAME}-* ]]; then
          # Prefix match (compose generated names)
          PREFIX_CONTAINERS="$PREFIX_CONTAINERS $(docker ps -aq --filter "name=${name}" 2>/dev/null || true)"
        fi
      done
      
      REMAINING_CONTAINERS=$(echo "$EXACT_CONTAINER $PREFIX_CONTAINERS" | tr -s ' ' | xargs)
      
      if [ -n "$REMAINING_CONTAINERS" ]; then
        echo "Found remaining containers: $REMAINING_CONTAINERS"
        # First stop, then remove
        echo "$REMAINING_CONTAINERS" | xargs -r docker stop -t 5 2>&1 || true
        echo "$REMAINING_CONTAINERS" | xargs -r docker rm -f 2>&1 || true
        sleep 5
      
      # Force sync by listing containers
      docker ps -a > /dev/null 2>&1
      fi
      # Phase 4: Final verification
      echo "Phase 4: Final verification..."
      ALL_NAMES_FINAL=$(docker ps -a --filter "name=${CONTAINER_NAME}" --format '{{ '{{' }}.Names{{ '}}' }}' 2>/dev/null || true)
      EXACT_CHECK=""
      PREFIX_CHECK=""
      
      for name in $ALL_NAMES_FINAL; do
        if [ "$name" = "${CONTAINER_NAME}" ]; then
          EXACT_CHECK=$(docker ps -aq --filter "name=${name}" 2>/dev/null || true)
        elif [[ "$name" == ${CONTAINER_NAME}-* ]]; then
          PREFIX_CHECK="$PREFIX_CHECK $(docker ps -aq --filter "name=${name}" 2>/dev/null || true)"
        fi
      done
      
      FINAL_CHECK=$(echo "$EXACT_CHECK $PREFIX_CHECK" | tr -s ' ' | xargs)
      
      if [ -n "$FINAL_CHECK" ]; then
        echo "⚠ WARNING: Some containers still exist:"
        docker ps -a | grep "${CONTAINER_NAME}" || true
        echo "Attempting final force removal..."
        # Stop first, then remove
        echo "$FINAL_CHECK" | xargs -r docker stop -t 5 2>&1 || true
        echo "$FINAL_CHECK" | xargs -r docker rm -f 2>&1 || true
        sleep 5
      
      # Force sync by listing containers
      docker ps -a > /dev/null 2>&1
      fi
      
      
      echo "Phase 4: Final verification..."
      FINAL_CHECK=$(docker ps -aq --filter "name=${CONTAINER_NAME}-" 2>/dev/null || true)
      
      if [ -n "$FINAL_CHECK" ]; then
        echo "⚠ WARNING: Some containers still exist:"
        docker ps -a --filter "name=${CONTAINER_NAME}-"
        echo "Attempting final force removal..."
        echo "$FINAL_CHECK" | xargs -r docker rm -f 2>&1 || true
        sleep 5
      
      # Force sync by listing containers
      docker ps -a > /dev/null 2>&1
      fi
      echo "✓ Cleanup completed - ready for deployment"
    executable: /bin/bash
  environment:
    CONTAINER_NAME: "{{ container_name }}"
    PROJECT_NAME: "{{ project_name }}"
    ADDON_NAME: "{{ instance_name }}"
    ADDON_DEPLOYMENT_PATH: "{{ addon_deployment_path }}"
    ADDON_BASE_PATH: "{{ addons_base_path }}"
  become: yes
  register: mongodb_cleanup_result
  changed_when: false

- name: Display cleanup output (debug)
  debug:
    msg: "{{ mongodb_cleanup_result.stdout_lines }}"
  when: mongodb_cleanup_result.stdout_lines is defined

- name: Final pre-start container check for {{ instance_name }}
  shell:
    cmd: |
      # One last check before docker-compose starts
      EXISTING=$(docker ps -aq --filter "name={{ project_name }}-{{ instance_name }}" 2>/dev/null || true)
      if [ -n "$EXISTING" ]; then
        echo "Found existing container(s), force removing..."
        echo "$EXISTING" | xargs -r docker stop -t 5 2>&1 || true
        echo "$EXISTING" | xargs -r docker rm -f 2>&1 || true
        sleep 3
        docker ps -a > /dev/null 2>&1  # Force sync
        echo "Removed: $EXISTING"
      else
        echo "No existing containers found"
      fi
    executable: /bin/bash
  become: yes
  changed_when: false

- name: Start {{ instance_name }} services (shell - more reliable than docker_compose_v2)
  shell:
    cmd: |
      cd "{{ addons_base_path }}/{{ instance_name }}"
      echo "Starting {{ container_name }}..."
      docker compose pull --quiet 2>&1 || true
      docker compose up -d --force-recreate 2>&1
      
      # Wait for container to be running
      for i in {1..10}; do
        if docker ps --filter "name={{ container_name }}" --format "{{ '{{' }}.Status{{ '}}' }}" | grep -q "Up"; then
          echo "✓ Container {{ container_name }} is running"
          exit 0
        fi
        echo "Waiting for container to start... ($i/10)"
        sleep 2
      done
      
      echo "❌ Container failed to start"
      docker logs {{ container_name }} 2>&1 | tail -20
      exit 1
    executable: /bin/bash
  become: yes
  register: mongodb_compose_result

- name: Wait for {{ instance_name }} to be ready
  wait_for:
    host: localhost
    port: "{{ MONGODB_PORT | default(27017) }}"
    delay: 5
    timeout: 60
    state: started
  when: mongodb_compose_result.changed

- name: Verify {{ instance_name }} is accessible
  shell: |
    docker exec {{ project_name }}-{{ instance_name }} mongosh --eval 'db.runCommand({ ping: 1 })' --quiet
  register: mongodb_health_check
  until: mongodb_health_check.rc == 0
  retries: 5
  delay: 2
  changed_when: false
  failed_when: mongodb_health_check.rc != 0

- name: Create application user in {{ instance_name }}
  shell: |
    docker exec {{ project_name }}-{{ instance_name }} mongosh admin \
      --username admin \
      --password {{ MONGODB_ROOT_PASSWORD }} \
      --eval "db.createUser({user: '{{ MONGODB_USER }}', pwd: '{{ MONGODB_PASSWORD }}', roles: [{role: 'readWrite', db: '{{ MONGODB_DB }}'}]})" \
      --quiet
  register: user_creation
  failed_when: false
  changed_when: "'Successfully added user' in user_creation.stdout"

- name: Verify {{ instance_name }} database access
  shell: |
    docker exec {{ project_name }}-{{ instance_name }} mongosh {{ MONGODB_DB }} \
      --username {{ MONGODB_USER }} \
      --password {{ MONGODB_PASSWORD }} \
      --eval "db.runCommand({ ping: 1 })" \
      --quiet
  register: db_check
  changed_when: false
  failed_when: false

- name: Display {{ instance_name }} deployment status
  debug:
    msg: "MongoDB is ready and database '{{ MONGODB_DB }}' is accessible by user '{{ MONGODB_USER }}'"
  when: db_check.rc == 0
