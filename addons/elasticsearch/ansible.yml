---
# Elasticsearch Addon Deployment

- name: Create {{ addon_name }} directories
  file:
    path: "{{ item }}"
    state: directory
    owner: "{{ superdeploy_user }}"
    group: "{{ superdeploy_group | default(superdeploy_user) }}"
    mode: '0755'
  loop:
    - "{{ addon_base_path }}/{{ addon_name }}"
    - "{{ addon_base_path }}/{{ addon_name }}/data"

- name: Stop existing services (with explicit project name)
  community.docker.docker_compose_v2:
    project_name: "{{ project_name }}"
    project_src: "{{ addon_base_path }}/{{ addon_name }}"
    state: absent
    remove_orphans: true
  become_user: "{{ superdeploy_user }}"
  register: compose_down_result
  failed_when: false
  ignore_errors: true

- name: Wait for Docker to complete cleanup
  command: sleep 2
  changed_when: false

- name: Verify container removal and force cleanup if needed
  shell: |
    set -e
    CNAME="{{ project_name }}-{{ addon_name }}"
    
    # Force remove by name
    docker rm -f "$CNAME" 2>/dev/null || true
    
    # Remove any matching containers by ID
    docker ps -aq --filter "name=$CNAME" 2>/dev/null | xargs -r docker rm -f 2>/dev/null || true
    
    # Clean Docker metadata cache
    docker container prune -f >/dev/null 2>&1 || true
    
    sleep 1
    
    # Final verification
    if docker ps -aq --filter "name=$CNAME" 2>/dev/null | grep -q .; then
      echo "FATAL: Container still exists after cleanup"
      docker ps -a
      exit 1
    fi
    
    echo "Container cleanup verified"
  args:
    executable: /bin/bash
  become_user: "{{ superdeploy_user }}"
  register: verify_cleanup
  changed_when: false
  failed_when: verify_cleanup.rc != 0

- name: Start {{ addon_name }} services (with explicit project name)
  community.docker.docker_compose_v2:
    project_name: "{{ project_name }}"
    project_src: "{{ addon_base_path }}/{{ addon_name }}"
    state: present
    pull: "always"
    recreate: "always"
    remove_orphans: true
  become_user: "{{ superdeploy_user }}"

- name: Wait for {{ addon_name }} to be ready
  wait_for:
    host: localhost
    port: 9200
    delay: 10
    timeout: 120
    state: started
