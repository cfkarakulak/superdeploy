---
# RabbitMQ Addon Deployment Tasks

- name: Create {{ addon_name }} directories
  file:
    path: "{{ item }}"
    state: directory
    owner: "{{ superdeploy_user }}"
    group: "{{ superdeploy_group | default(superdeploy_user) }}"
    mode: '0755'
  loop:
    - "{{ addon_base_path }}/{{ addon_name }}"
    - "{{ addon_base_path }}/{{ addon_name }}/data"

# Note: docker-compose.yml and .env are already rendered by orchestration/addon-deployer
# This keeps the deployment logic clean and focused on service-specific tasks

- name: CLEANUP - Nuclear option container removal
  shell: |
    set -e
    FILTER_NAME="{{ project_name }}-{{ addon_name }}"
    CONTAINERS=$$(docker ps -aq --filter "name=$${FILTER_NAME}" 2>/dev/null || echo "")
    if [ -n "$$CONTAINERS" ]; then
      for CID in $$CONTAINERS; do
        docker kill "$$CID" 2>/dev/null || true
        docker stop -t 0 "$$CID" 2>/dev/null || true
      done
      for CID in $$CONTAINERS; do
        NETWORKS=$$(docker inspect "$$CID" --format '{% raw %}{{range $net, $_ := .NetworkSettings.Networks}}{{$net}} {{end}}{% endraw %}' 2>/dev/null || echo "")
        for NET in $$NETWORKS; do
          docker network disconnect -f "$$NET" "$$CID" 2>/dev/null || true
        done
      done
      for CID in $$CONTAINERS; do
        docker rm -fv "$$CID" 2>/dev/null || true
      done
    fi
    for i in {1..5}; do
      docker kill "$${FILTER_NAME}" 2>/dev/null || true
      docker stop -t 0 "$${FILTER_NAME}" 2>/dev/null || true
      docker rm -fv "$${FILTER_NAME}" 2>/dev/null || true
    done
    docker container prune -f --filter "label=com.docker.compose.project={{ project_name }}" 2>/dev/null || true
    sleep 2
    REMAINING=$$(docker ps -aq --filter "name=$${FILTER_NAME}" 2>/dev/null || echo "")
    if [ -n "$$REMAINING" ]; then
      docker system prune -af --volumes --filter "label=com.docker.compose.service={{ addon_name }}" 2>/dev/null || true
      sleep 1
      STILL_REMAINING=$$(docker ps -aq --filter "name=$${FILTER_NAME}" 2>/dev/null || echo "")
      if [ -n "$$STILL_REMAINING" ]; then
        exit 1
      fi
    fi
    echo "Nuclear cleanup successful"
  become_user: "{{ superdeploy_user }}"
  register: cleanup_result
  changed_when: false
  failed_when: cleanup_result.rc != 0

- name: Start {{ addon_name }} services (fresh deployment)
  community.docker.docker_compose_v2:
    project_src: "{{ addon_base_path }}/{{ addon_name }}"
    state: present
    pull: "always"
    recreate: "always"
    remove_orphans: true
  become_user: "{{ superdeploy_user }}"
  register: rabbitmq_compose_result

- name: Wait for {{ addon_name }} container to be running
  shell: docker inspect -f '{% raw %}{{.State.Running}}{% endraw %}' {{ project_name }}-{{ addon_name }}
  register: container_running
  until: container_running.stdout == 'true'
  retries: 10
  delay: 2
  changed_when: false
  when: rabbitmq_compose_result.changed

- name: Wait for {{ addon_name }} management plugin
  shell: |
    docker exec {{ project_name }}-{{ addon_name }} rabbitmq-plugins list -e | grep -q rabbitmq_management
  register: management_check
  until: management_check.rc == 0
  retries: 5
  delay: 3
  changed_when: false

- name: Verify {{ addon_name }} virtual host exists
  shell: |
    docker exec {{ project_name }}-{{ addon_name }} rabbitmqctl list_vhosts | grep -qw /
  register: vhost_check
  changed_when: false
  failed_when: false

- name: Set permissions for user on virtual host
  shell: |
    docker exec {{ project_name }}-{{ addon_name }} rabbitmqctl set_permissions -p / {{ env_vars.RABBITMQ_USER }} ".*" ".*" ".*"
  changed_when: false
  failed_when: false

- name: Display {{ addon_name }} deployment status
  debug:
    msg: "RabbitMQ is ready - Management UI available on port {{ env_vars.RABBITMQ_MANAGEMENT_PORT | default(15672) }}, AMQP on port {{ env_vars.RABBITMQ_PORT | default(5672) }}"
