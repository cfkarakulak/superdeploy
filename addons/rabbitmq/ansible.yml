---
# RabbitMQ Addon Deployment Tasks

- name: Create {{ addon_name }} directories
  file:
    path: "{{ item }}"
    state: directory
    owner: "{{ superdeploy_user }}"
    group: "{{ superdeploy_group | default(superdeploy_user) }}"
    mode: '0755'
  loop:
    - "{{ addon_base_path }}/{{ addon_name }}"
    - "{{ addon_base_path }}/{{ addon_name }}/data"

# Note: docker-compose.yml and .env are already rendered by orchestration/addon-deployer
# This keeps the deployment logic clean and focused on service-specific tasks

- name: Deploy {{ addon_name }} with intelligent cleanup
  shell:
    cmd: |
      set -e
      cd "${ADDON_BASE_PATH}/${ADDON_NAME}"
      
      echo "Starting cleanup for ${PROJECT_NAME}-${ADDON_NAME}..."
      
      # Phase 1: Stop via Docker Compose (graceful shutdown)
      echo "Phase 1: Stopping containers via Docker Compose..."
      docker compose --project-name "${PROJECT_NAME}-${ADDON_NAME}" down --remove-orphans --timeout 30 2>&1 || true
      
      # Phase 2: Wait for Docker daemon to sync
      echo "Phase 2: Waiting for Docker daemon to sync..."
      sleep 3
      
      # Phase 3: Aggressive cleanup with verification loop
      echo "Phase 3: Verifying all containers are removed..."
      for attempt in 1 2 3 4 5; do
        # Get ALL matching containers (running, stopped, exited)
        CONTAINER_IDS=$(docker ps -aq --filter "name=${PROJECT_NAME}-${ADDON_NAME}" 2>/dev/null || true)
        
        if [ -z "$CONTAINER_IDS" ]; then
          echo "✓ All containers removed successfully (attempt $attempt)"
          break
        fi
        
        echo "Attempt $attempt: Found remaining containers: $CONTAINER_IDS"
        
        # Force kill then remove
        for cid in $CONTAINER_IDS; do
          echo "  - Killing container: $cid"
          docker kill "$cid" 2>&1 || true
          sleep 1
          echo "  - Removing container: $cid"
          docker rm -f "$cid" 2>&1 || true
        done
        
        # Verify removal
        sleep 2
        REMAINING=$(docker ps -aq --filter "name=${PROJECT_NAME}-${ADDON_NAME}" 2>/dev/null | wc -l)
        
        if [ "$REMAINING" -eq 0 ]; then
          echo "✓ Cleanup successful after $attempt attempt(s)"
          break
        fi
        
        if [ $attempt -eq 5 ]; then
          echo "⚠ ERROR: Failed to remove all containers after 5 attempts"
          docker ps -a --filter "name=${PROJECT_NAME}-${ADDON_NAME}"
          exit 1
        fi
        
        echo "  Waiting before retry..."
        sleep 3
      done
      
      # Phase 4: Final sync and prune
      echo "Phase 4: Final cleanup..."
      docker container prune -f >/dev/null 2>&1 || true
      sleep 3
      
      # Final verification
      FINAL_CHECK=$(docker ps -aq --filter "name=${PROJECT_NAME}-${ADDON_NAME}" 2>/dev/null || true)
      if [ -n "$FINAL_CHECK" ]; then
        echo "⚠ ERROR: Containers still exist after cleanup!"
        docker ps -a --filter "name=${PROJECT_NAME}-${ADDON_NAME}"
        exit 1
      fi
      
      echo "✓ Cleanup completed successfully - ready for deployment"
      
      # Critical: Wait for Docker daemon to fully update its metadata
      echo "Waiting for Docker daemon to sync metadata..."
      sleep 5
    executable: /bin/bash
  environment:
    PROJECT_NAME: "{{ project_name }}"
    ADDON_NAME: "{{ addon_name }}"
    ADDON_BASE_PATH: "{{ addon_base_path }}"
  become: yes
  register: rabbitmq_cleanup_result
  changed_when: false

- name: Start {{ addon_name }} services (with explicit project name)
  community.docker.docker_compose_v2:
    project_name: "{{ project_name }}-{{ addon_name }}"
    project_src: "{{ addon_base_path }}/{{ addon_name }}"
    state: present
    pull: "always"
    recreate: "always"
    remove_orphans: true
  become: yes
  register: rabbitmq_compose_result

- name: Wait for {{ addon_name }} container to be running
  shell: docker inspect -f '{% raw %}{{.State.Running}}{% endraw %}' {{ project_name }}-{{ addon_name }}
  register: container_running
  until: container_running.stdout == 'true'
  retries: 10
  delay: 2
  changed_when: false
  when: rabbitmq_compose_result.changed

- name: Wait for {{ addon_name }} management plugin
  shell: |
    docker exec {{ project_name }}-{{ addon_name }} rabbitmq-plugins list -e | grep -q rabbitmq_management
  register: management_check
  until: management_check.rc == 0
  retries: 5
  delay: 3
  changed_when: false

- name: Verify {{ addon_name }} virtual host exists
  shell: |
    docker exec {{ project_name }}-{{ addon_name }} rabbitmqctl list_vhosts | grep -qw /
  register: vhost_check
  changed_when: false
  failed_when: false

- name: Set permissions for user on virtual host
  shell: |
    docker exec {{ project_name }}-{{ addon_name }} rabbitmqctl set_permissions -p / {{ env_vars.RABBITMQ_USER }} ".*" ".*" ".*"
  changed_when: false
  failed_when: false

- name: Display {{ addon_name }} deployment status
  debug:
    msg: "RabbitMQ is ready - Management UI available on port {{ env_vars.RABBITMQ_MANAGEMENT_PORT | default(15672) }}, AMQP on port {{ env_vars.RABBITMQ_PORT | default(5672) }}"
