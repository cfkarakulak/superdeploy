#!/usr/bin/env bash
# =============================================================================
# SuperDeploy CLI - Heroku-like UX for self-hosted deployment
# =============================================================================
# Usage:
#   superdeploy config:set KEY=VAL -a api -e production
#   superdeploy logs -a api
#   superdeploy run api "python manage.py migrate"
#   superdeploy scale api=3
#   superdeploy releases -a api
#   superdeploy rollback vNN -a api
#   superdeploy promote <sha> -a api (staging → production)

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Load .env
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
ENV_FILE="$PROJECT_ROOT/.env"

if [ ! -f "$ENV_FILE" ]; then
  echo -e "${RED}❌ Error: .env file not found at $ENV_FILE${NC}"
  exit 1
fi

set -a
source "$ENV_FILE"
set +a

# =============================================================================
# Helper Functions
# =============================================================================

usage() {
  cat << EOF
${GREEN}SuperDeploy CLI${NC} - Heroku-like deployment tool

${YELLOW}USAGE:${NC}
  superdeploy <command> [options]

${YELLOW}COMMANDS:${NC}

  ${BLUE}Config Management:${NC}
    config:set KEY=VAL [-a APP] [-e ENV]     Set environment variable
    config:get KEY [-a APP] [-e ENV]         Get environment variable
    config:unset KEY [-a APP] [-e ENV]       Unset environment variable
    config [-a APP] [-e ENV]                 List all environment variables

  ${BLUE}Deployment:${NC}
    deploy [-a APP] [-e ENV]                 Trigger deployment
    promote SHA [-a APP]                     Promote staging to production
    releases [-a APP] [-e ENV]               List releases
    rollback VERSION [-a APP] [-e ENV]       Rollback to specific version

  ${BLUE}Runtime:${NC}
    run APP "COMMAND"                        Run one-off command
    scale APP=REPLICAS                       Scale service
    restart APP                              Restart service
    logs [-a APP] [-f] [-n LINES]            View logs

  ${BLUE}Info:${NC}
    apps                                     List all apps
    info [-a APP]                            Show app info
    status                                   Show infrastructure status

${YELLOW}OPTIONS:${NC}
  -a, --app APP          App name (api, dashboard, services)
  -e, --env ENV          Environment (production, staging)
  -f, --follow           Follow logs (tail -f)
  -n, --lines N          Number of lines to show
  -h, --help             Show this help

${YELLOW}EXAMPLES:${NC}
  ${GREEN}superdeploy config:set API_DEBUG=false -a api -e production${NC}
  ${GREEN}superdeploy logs -a api -f${NC}
  ${GREEN}superdeploy run api "python manage.py migrate"${NC}
  ${GREEN}superdeploy scale api=3${NC}
  ${GREEN}superdeploy promote abc123 -a api${NC}
  ${GREEN}superdeploy rollback v42 -a api${NC}

EOF
}

error() {
  echo -e "${RED}❌ Error: $1${NC}" >&2
  exit 1
}

success() {
  echo -e "${GREEN}✅ $1${NC}"
}

info() {
  echo -e "${BLUE}ℹ️  $1${NC}"
}

warning() {
  echo -e "${YELLOW}⚠️  $1${NC}"
}

# Parse global options
APP=""
ENVIRONMENT="production"
FOLLOW=false
LINES=100

parse_opts() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      -a|--app)
        APP="$2"
        shift 2
        ;;
      -e|--env)
        ENVIRONMENT="$2"
        shift 2
        ;;
      -f|--follow)
        FOLLOW=true
        shift
        ;;
      -n|--lines)
        LINES="$2"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        break
        ;;
    esac
  done
}

# =============================================================================
# GitHub API Functions
# =============================================================================

github_api() {
  local method="$1"
  local endpoint="$2"
  local data="$3"
  
  if [ -z "$GITHUB_TOKEN" ] || [ "$GITHUB_TOKEN" = "your-github-token" ]; then
    error "GITHUB_TOKEN not set in .env"
  fi
  
  local org="cheapaio"  # TODO: Make configurable
  local url="https://api.github.com/repos/${org}/${APP}${endpoint}"
  
  if [ -n "$data" ]; then
    curl -sS -X "$method" \
      -H "Authorization: token $GITHUB_TOKEN" \
      -H "Accept: application/vnd.github.v3+json" \
      -H "Content-Type: application/json" \
      -d "$data" \
      "$url"
  else
    curl -sS -X "$method" \
      -H "Authorization: token $GITHUB_TOKEN" \
      -H "Accept: application/vnd.github.v3+json" \
      "$url"
  fi
}

# =============================================================================
# Config Commands
# =============================================================================

cmd_config_set() {
  parse_opts "$@"
  shift $((OPTIND - 1))
  
  local key_val="$1"
  if [ -z "$key_val" ]; then
    error "Usage: superdeploy config:set KEY=VALUE -a APP -e ENV"
  fi
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  local key="${key_val%%=*}"
  local value="${key_val#*=}"
  
  info "Setting $key for $APP ($ENVIRONMENT)..."
  
  # GitHub Environment Secrets API
  local env_id=$(github_api GET "/environments" | jq -r ".environments[] | select(.name==\"$ENVIRONMENT\") | .id")
  
  if [ -z "$env_id" ] || [ "$env_id" = "null" ]; then
    error "Environment '$ENVIRONMENT' not found. Create it first on GitHub."
  fi
  
  # Encrypt secret (requires libsodium)
  # For now, use GitHub API's public key endpoint
  local public_key_response=$(github_api GET "/environments/$env_id/secrets/public-key")
  local public_key=$(echo "$public_key_response" | jq -r '.key')
  local key_id=$(echo "$public_key_response" | jq -r '.key_id')
  
  # Encrypt value with public key (requires age or libsodium)
  # Simplified: use GitHub API directly (assumes gh cli or similar)
  
  warning "GitHub Secrets API requires encryption. Use GitHub UI or 'gh' CLI for now."
  echo ""
  echo "  gh secret set $key --env $ENVIRONMENT --repo cheapaio/$APP --body \"$value\""
  echo ""
  info "Alternatively, set via GitHub UI:"
  echo "  https://github.com/cheapaio/$APP/settings/environments"
}

cmd_config_get() {
  parse_opts "$@"
  shift $((OPTIND - 1))
  
  local key="$1"
  if [ -z "$key" ]; then
    error "Usage: superdeploy config:get KEY -a APP -e ENV"
  fi
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  warning "GitHub doesn't allow reading secret values via API (security)."
  info "Secret '$key' can only be viewed/edited in GitHub UI:"
  echo "  https://github.com/cheapaio/$APP/settings/environments"
}

cmd_config_list() {
  parse_opts "$@"
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  info "Listing environment secrets for $APP ($ENVIRONMENT)..."
  
  local env_id=$(github_api GET "/environments" | jq -r ".environments[] | select(.name==\"$ENVIRONMENT\") | .id")
  
  if [ -z "$env_id" ] || [ "$env_id" = "null" ]; then
    error "Environment '$ENVIRONMENT' not found"
  fi
  
  github_api GET "/environments/$env_id/secrets" | jq -r '.secrets[] | .name'
}

# =============================================================================
# Deployment Commands
# =============================================================================

cmd_deploy() {
  parse_opts "$@"
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  info "Triggering deployment for $APP ($ENVIRONMENT)..."
  
  # Trigger via Forgejo workflow_dispatch
  local forgejo_url="${FORGEJO_BASE_URL:-http://${CORE_EXTERNAL_IP}:3001}"
  local payload=$(jq -n \
    --arg env "$ENVIRONMENT" \
    --arg app "$APP" \
    '{
      ref: "master",
      inputs: {
        environment: $env,
        services: $app,
        image_tags: "{\"" + $app + "\":\"latest\"}",
        migrate: "false"
      }
    }')
  
  curl -sS -X POST \
    -H "Authorization: token $FORGEJO_PAT" \
    -H "Content-Type: application/json" \
    "${forgejo_url}/api/v1/repos/${FORGEJO_ORG}/superdeploy-app/actions/workflows/deploy.yml/dispatches" \
    -d "$payload" && \
    success "Deployment triggered!" || \
    error "Deployment trigger failed"
  
  echo ""
  info "Check status: ${forgejo_url}/${FORGEJO_ORG}/superdeploy-app/actions"
}

cmd_promote() {
  parse_opts "$@"
  shift $((OPTIND - 1))
  
  local sha="$1"
  if [ -z "$sha" ]; then
    error "Usage: superdeploy promote SHA -a APP"
  fi
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  info "Promoting staging build $sha to production for $APP..."
  
  local forgejo_url="${FORGEJO_BASE_URL:-http://${CORE_EXTERNAL_IP}:3001}"
  local payload=$(jq -n \
    --arg app "$APP" \
    --arg sha "$sha" \
    '{
      ref: "master",
      inputs: {
        environment: "prod",
        services: $app,
        image_tags: "{\"" + $app + "\":\"" + $sha + "\"}",
        migrate: "false"
      }
    }')
  
  curl -sS -X POST \
    -H "Authorization: token $FORGEJO_PAT" \
    -H "Content-Type: application/json" \
    "${forgejo_url}/api/v1/repos/${FORGEJO_ORG}/superdeploy-app/actions/workflows/deploy.yml/dispatches" \
    -d "$payload" && \
    success "Promotion triggered!" || \
    error "Promotion failed"
}

cmd_releases() {
  parse_opts "$@"
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  info "Fetching releases for $APP..."
  
  local forgejo_url="${FORGEJO_BASE_URL:-http://${CORE_EXTERNAL_IP}:3001}"
  
  # Fetch recent workflow runs
  curl -sS \
    -H "Authorization: token $FORGEJO_PAT" \
    "${forgejo_url}/api/v1/repos/${FORGEJO_ORG}/superdeploy-app/actions/runs?limit=20" | \
    jq -r '.workflow_runs[] | select(.name=="Deploy Multi-Service (Reusable)") | "\(.id)\t\(.created_at)\t\(.conclusion // "running")"' | \
    column -t -s $'\t'
}

cmd_rollback() {
  parse_opts "$@"
  shift $((OPTIND - 1))
  
  local version="$1"
  if [ -z "$version" ]; then
    error "Usage: superdeploy rollback VERSION -a APP"
  fi
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  warning "Rollback: Deploy previous image version"
  info "Find version SHA from releases, then run:"
  echo "  superdeploy promote <sha> -a $APP"
}

# =============================================================================
# Runtime Commands
# =============================================================================

cmd_run() {
  local app="$1"
  local command="$2"
  
  if [ -z "$app" ] || [ -z "$command" ]; then
    error "Usage: superdeploy run APP \"COMMAND\""
  fi
  
  info "Running one-off command on $app..."
  
  # SSH into VM and run docker exec
  ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cd /opt/superdeploy/compose && docker compose exec $app $command"
}

cmd_scale() {
  local scale_arg="$1"
  if [ -z "$scale_arg" ]; then
    error "Usage: superdeploy scale APP=REPLICAS"
  fi
  
  local app="${scale_arg%%=*}"
  local replicas="${scale_arg#*=}"
  
  info "Scaling $app to $replicas replicas..."
  
  ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cd /opt/superdeploy/compose && docker compose up -d --scale $app=$replicas"
  
  success "$app scaled to $replicas"
}

cmd_restart() {
  local app="$1"
  if [ -z "$app" ]; then
    error "Usage: superdeploy restart APP"
  fi
  
  info "Restarting $app..."
  
  ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cd /opt/superdeploy/compose && docker compose restart $app"
  
  success "$app restarted"
}

cmd_logs() {
  parse_opts "$@"
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  local follow_flag=""
  if [ "$FOLLOW" = true ]; then
    follow_flag="-f"
  fi
  
  info "Fetching logs for $APP (last $LINES lines)..."
  
  ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cd /opt/superdeploy/compose && docker compose logs $follow_flag --tail=$LINES $APP"
}

# =============================================================================
# Info Commands
# =============================================================================

cmd_apps() {
  info "Available apps:"
  echo "  - api"
  echo "  - dashboard"
  echo "  - services"
}

cmd_info() {
  parse_opts "$@"
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  info "App info for $APP:"
  
  ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cd /opt/superdeploy/compose && docker compose ps $APP && echo && docker compose images $APP"
}

cmd_status() {
  info "Infrastructure status:"
  echo ""
  echo "Core VM:   ${CORE_EXTERNAL_IP}"
  echo "Scrape VM: ${SCRAPE_EXTERNAL_IP}"
  echo "Proxy VM:  ${PROXY_EXTERNAL_IP}"
  echo ""
  
  info "Services:"
  ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cd /opt/superdeploy/compose && docker compose ps --format 'table {{.Name}}\t{{.Status}}\t{{.Ports}}'"
}

# =============================================================================
# Main
# =============================================================================

if [ $# -eq 0 ]; then
  usage
  exit 0
fi

COMMAND="$1"
shift

case "$COMMAND" in
  config:set)
    cmd_config_set "$@"
    ;;
  config:get)
    cmd_config_get "$@"
    ;;
  config:unset)
    warning "Unset not yet implemented. Use GitHub UI."
    ;;
  config)
    cmd_config_list "$@"
    ;;
  deploy)
    cmd_deploy "$@"
    ;;
  promote)
    cmd_promote "$@"
    ;;
  releases)
    cmd_releases "$@"
    ;;
  rollback)
    cmd_rollback "$@"
    ;;
  run)
    cmd_run "$@"
    ;;
  scale)
    cmd_scale "$@"
    ;;
  restart)
    cmd_restart "$@"
    ;;
  logs)
    cmd_logs "$@"
    ;;
  apps)
    cmd_apps
    ;;
  info)
    cmd_info "$@"
    ;;
  status)
    cmd_status
    ;;
  -h|--help)
    usage
    ;;
  *)
    error "Unknown command: $COMMAND. Run 'superdeploy --help' for usage."
    ;;
esac

