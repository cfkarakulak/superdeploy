#!/usr/bin/env bash
# =============================================================================
# SuperDeploy CLI - Heroku-like UX for self-hosted deployment
# =============================================================================
# Usage:
#   superdeploy config:set KEY=VAL -a api -e production
#   superdeploy logs -a api
#   superdeploy run api "python manage.py migrate"
#   superdeploy scale api=3
#   superdeploy releases -a api
#   superdeploy rollback vNN -a api
#   superdeploy promote <sha> -a api (staging ‚Üí production)

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Load .env - smart detection
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Try multiple locations
if [ -f "$PWD/.env" ]; then
  ENV_FILE="$PWD/.env"
elif [ -f "$HOME/.superdeploy/.env" ]; then
  ENV_FILE="$HOME/.superdeploy/.env"
elif [ -f "$(dirname "$SCRIPT_DIR")/.env" ]; then
  ENV_FILE="$(dirname "$SCRIPT_DIR")/.env"
else
  echo -e "${RED}‚ùå Error: .env file not found!${NC}"
  echo ""
  echo "Searched locations:"
  echo "  - $PWD/.env"
  echo "  - $HOME/.superdeploy/.env"
  echo "  - $(dirname "$SCRIPT_DIR")/.env"
  echo ""
  echo "Solution:"
  echo "  1. cd to your superdeploy directory"
  echo "  2. Or run: superdeploy init (to create ~/.superdeploy/.env)"
  exit 1
fi

PROJECT_ROOT="$(dirname "$ENV_FILE")"

set -a
source "$ENV_FILE"
set +a

# =============================================================================
# Helper Functions
# =============================================================================

usage() {
  cat << EOF
${GREEN}SuperDeploy CLI${NC} - Heroku-like deployment tool

${YELLOW}USAGE:${NC}
  superdeploy <command> [options]

${YELLOW}COMMANDS:${NC}

  ${BLUE}Config Management:${NC}
    sync                                     üî• Sync ALL secrets from .env to GitHub/Forgejo
    config:set KEY=VAL [-a APP] [-e ENV]     Set environment variable
    config:get KEY [-a APP] [-e ENV]         Get environment variable
    config:unset KEY [-a APP] [-e ENV]       Unset environment variable
    config [-a APP] [-e ENV]                 List all environment variables

  ${BLUE}Deployment:${NC}
    deploy [-a APP] [-e ENV]                 Trigger deployment
    promote SHA [-a APP]                     Promote staging to production
    releases [-a APP] [-e ENV]               List releases
    rollback VERSION [-a APP] [-e ENV]       Rollback to specific version

  ${BLUE}Runtime:${NC}
    run APP "COMMAND"                        Run one-off command
    scale APP=REPLICAS                       Scale service
    restart APP                              Restart service
    logs [-a APP] [-f] [-n LINES]            View logs

  ${BLUE}Info:${NC}
    apps                                     List all apps
    info [-a APP]                            Show app info
    status                                   Show infrastructure status

${YELLOW}OPTIONS:${NC}
  -a, --app APP          App name (api, dashboard, services)
  -e, --env ENV          Environment (production, staging)
  -f, --follow           Follow logs (tail -f)
  -n, --lines N          Number of lines to show
  -h, --help             Show this help

${YELLOW}EXAMPLES:${NC}
  ${GREEN}superdeploy config:set API_DEBUG=false -a api -e production${NC}
  ${GREEN}superdeploy logs -a api -f${NC}
  ${GREEN}superdeploy run api "python manage.py migrate"${NC}
  ${GREEN}superdeploy scale api=3${NC}
  ${GREEN}superdeploy promote abc123 -a api${NC}
  ${GREEN}superdeploy rollback v42 -a api${NC}

EOF
}

error() {
  echo -e "${RED}‚ùå Error: $1${NC}" >&2
  exit 1
}

success() {
  echo -e "${GREEN}‚úÖ $1${NC}"
}

info() {
  echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

warning() {
  echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

# Parse global options
APP=""
ENVIRONMENT="production"
FOLLOW=false
LINES=100

parse_opts() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      -a|--app)
        APP="$2"
        shift 2
        ;;
      -e|--env)
        ENVIRONMENT="$2"
        shift 2
        ;;
      -f|--follow)
        FOLLOW=true
        shift
        ;;
      -n|--lines)
        LINES="$2"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        break
        ;;
    esac
  done
}

# =============================================================================
# GitHub API Functions
# =============================================================================

github_api() {
  local method="$1"
  local endpoint="$2"
  local data="$3"
  
  if [ -z "$GITHUB_TOKEN" ] || [ "$GITHUB_TOKEN" = "your-github-token" ]; then
    error "GITHUB_TOKEN not set in .env"
  fi
  
  local org="cheapaio"  # TODO: Make configurable
  local url="https://api.github.com/repos/${org}/${APP}${endpoint}"
  
  if [ -n "$data" ]; then
    curl -sS -X "$method" \
      -H "Authorization: token $GITHUB_TOKEN" \
      -H "Accept: application/vnd.github.v3+json" \
      -H "Content-Type: application/json" \
      -d "$data" \
      "$url"
  else
    curl -sS -X "$method" \
      -H "Authorization: token $GITHUB_TOKEN" \
      -H "Accept: application/vnd.github.v3+json" \
      "$url"
  fi
}

# =============================================================================
# Sync Command (Smart Secret Distribution)
# =============================================================================

cmd_sync() {
  info "üîÑ Starting smart secret sync..."
  echo ""
  
  # Check requirements
  if [ -z "$GITHUB_TOKEN" ] || [ "$GITHUB_TOKEN" = "your-github-token" ]; then
    error "GITHUB_TOKEN not set in .env"
  fi
  
  if [ -z "$FORGEJO_PAT" ]; then
    warning "FORGEJO_PAT not set - will create one"
    echo ""
    
    # Auto-generate Forgejo PAT
    info "Creating Forgejo PAT..."
    CORE_IP="${CORE_EXTERNAL_IP}"
    PAT=$(curl -sS -X POST "http://$CORE_IP:3001/api/v1/users/${FORGEJO_ADMIN_USER}/tokens" \
      -u "${FORGEJO_ADMIN_USER}:${FORGEJO_ADMIN_PASSWORD}" \
      -H "Content-Type: application/json" \
      -d '{"name":"superdeploy-cli","scopes":["write:repository","write:activitypub"]}' | jq -r '.sha1')
    
    if [ -n "$PAT" ] && [ "$PAT" != "null" ]; then
      echo "FORGEJO_PAT=$PAT" >> "$ENV_FILE"
      export FORGEJO_PAT="$PAT"
      success "Forgejo PAT created and saved!"
    else
      error "Failed to create Forgejo PAT"
    fi
  fi
  
  # Get AGE public key from VM
  info "Fetching AGE public key from VM..."
  AGE_PUB_KEY=$(ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cat /opt/forgejo-runner/.age/public_key.txt" 2>/dev/null)
  
  if [ -z "$AGE_PUB_KEY" ]; then
    error "Failed to fetch AGE public key from VM"
  fi
  
  success "AGE public key: $AGE_PUB_KEY"
  echo ""
  
  # Determine which apps to sync
  local APPS=("api" "dashboard" "services")
  local ORG="cheapaio"  # TODO: Make configurable
  
  info "Will sync secrets to GitHub repos:"
  for app in "${APPS[@]}"; do
    echo "  ‚Ä¢ $ORG/$app"
  done
  echo ""
  
  read -p "Continue? (y/N): " -n 1 -r
  echo ""
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    warning "Sync cancelled"
    exit 0
  fi
  
  # Sync to each app
  for app in "${APPS[@]}"; do
    info "Syncing $app..."
    
    # 1. Set repository secrets (same for all environments)
    info "  ‚îî‚îÄ Repository secrets..."
    
    # Use gh CLI if available, otherwise show manual instructions
    if command -v gh &> /dev/null; then
      gh secret set AGE_PUBLIC_KEY -R "$ORG/$app" -b "$AGE_PUB_KEY" 2>/dev/null && echo "    ‚úÖ AGE_PUBLIC_KEY" || echo "    ‚ö†Ô∏è  AGE_PUBLIC_KEY (skipped)"
      gh secret set FORGEJO_BASE_URL -R "$ORG/$app" -b "http://${CORE_EXTERNAL_IP}:3001" 2>/dev/null && echo "    ‚úÖ FORGEJO_BASE_URL" || echo "    ‚ö†Ô∏è  FORGEJO_BASE_URL (skipped)"
      gh secret set FORGEJO_ORG -R "$ORG/$app" -b "$FORGEJO_ORG" 2>/dev/null && echo "    ‚úÖ FORGEJO_ORG" || echo "    ‚ö†Ô∏è  FORGEJO_ORG (skipped)"
      gh secret set FORGEJO_PAT -R "$ORG/$app" -b "$FORGEJO_PAT" 2>/dev/null && echo "    ‚úÖ FORGEJO_PAT" || echo "    ‚ö†Ô∏è  FORGEJO_PAT (skipped)"
      gh secret set DOCKER_USERNAME -R "$ORG/$app" -b "$DOCKER_USERNAME" 2>/dev/null && echo "    ‚úÖ DOCKER_USERNAME" || echo "    ‚ö†Ô∏è  DOCKER_USERNAME (skipped)"
      gh secret set DOCKER_TOKEN -R "$ORG/$app" -b "$DOCKER_TOKEN" 2>/dev/null && echo "    ‚úÖ DOCKER_TOKEN" || echo "    ‚ö†Ô∏è  DOCKER_TOKEN (skipped)"
      gh secret set DOCKER_ORG -R "$ORG/$app" -b "$DOCKER_ORG" 2>/dev/null && echo "    ‚úÖ DOCKER_ORG" || echo "    ‚ö†Ô∏è  DOCKER_ORG (skipped)"
    else
      warning "  'gh' CLI not found - showing manual instructions"
      echo ""
      echo "  Install: brew install gh"
      echo "  Then run: gh auth login"
      echo ""
      echo "  Or add manually at:"
      echo "  https://github.com/$ORG/$app/settings/secrets/actions"
      echo ""
    fi
    
    # 2. Set environment secrets (production)
    info "  ‚îî‚îÄ Environment secrets (production)..."
    
    # Create env file for this app
    local ENV_TEMPLATE=""
    
    case $app in
      api)
        ENV_TEMPLATE="POSTGRES_HOST=postgres
POSTGRES_USER=${POSTGRES_USER:-superdeploy}
POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-CHANGE_ME}
POSTGRES_DB=${POSTGRES_DB:-superdeploy_db}
POSTGRES_PORT=5432
RABBITMQ_HOST=rabbitmq
RABBITMQ_USER=${RABBITMQ_USER:-superdeploy}
RABBITMQ_PASSWORD=${RABBITMQ_PASSWORD:-CHANGE_ME}
RABBITMQ_PORT=5672
REDIS_HOST=redis
REDIS_PASSWORD=${REDIS_PASSWORD:-CHANGE_ME}
API_SECRET_KEY=${API_SECRET_KEY:-CHANGE_ME_32_CHARS_MIN}
API_DEBUG=false
API_BASE_URL=http://${CORE_EXTERNAL_IP}:8000
PUBLIC_URL=http://${CORE_EXTERNAL_IP}
SENTRY_DSN="
        ;;
      dashboard)
        ENV_TEMPLATE="DASHBOARD_API_URL=http://${CORE_EXTERNAL_IP}:8000
DASHBOARD_PUBLIC_URL=http://${CORE_EXTERNAL_IP}
DASHBOARD_PORT=3000
NEXT_PUBLIC_API_URL=http://${CORE_EXTERNAL_IP}:8000"
        ;;
      services)
        ENV_TEMPLATE="POSTGRES_HOST=postgres
POSTGRES_USER=${POSTGRES_USER:-superdeploy}
POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-CHANGE_ME}
POSTGRES_DB=${POSTGRES_DB:-superdeploy_db}
RABBITMQ_HOST=rabbitmq
RABBITMQ_USER=${RABBITMQ_USER:-superdeploy}
RABBITMQ_PASSWORD=${RABBITMQ_PASSWORD:-CHANGE_ME}
SERVICES_WORKER_COUNT=4
SERVICES_LOG_LEVEL=info"
        ;;
    esac
    
    # Save template
    local TMP_ENV="/tmp/$app.env"
    echo "$ENV_TEMPLATE" > "$TMP_ENV"
    
    if command -v gh &> /dev/null; then
      # Parse env file and set each secret
      while IFS='=' read -r key value; do
        [ -z "$key" ] && continue
        [[ "$key" =~ ^#.* ]] && continue
        gh secret set "$key" -R "$ORG/$app" --env production -b "$value" 2>/dev/null && echo "    ‚úÖ $key" || echo "    ‚ö†Ô∏è  $key (skipped)"
      done < "$TMP_ENV"
    else
      echo "    ‚ö†Ô∏è  Install 'gh' CLI to auto-sync environment secrets"
    fi
    
    rm -f "$TMP_ENV"
    echo ""
  done
  
  success "üéâ Sync complete!"
  echo ""
  info "Next steps:"
  echo "  1. Verify secrets: https://github.com/$ORG/api/settings/secrets"
  echo "  2. Test deployment: cd ~/app-repos/api && git push origin production"
}

# =============================================================================
# Config Commands
# =============================================================================

cmd_config_set() {
  parse_opts "$@"
  shift $((OPTIND - 1))
  
  local key_val="$1"
  if [ -z "$key_val" ]; then
    error "Usage: superdeploy config:set KEY=VALUE -a APP -e ENV"
  fi
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  local key="${key_val%%=*}"
  local value="${key_val#*=}"
  
  info "Setting $key for $APP ($ENVIRONMENT)..."
  
  # GitHub Environment Secrets API
  local env_id=$(github_api GET "/environments" | jq -r ".environments[] | select(.name==\"$ENVIRONMENT\") | .id")
  
  if [ -z "$env_id" ] || [ "$env_id" = "null" ]; then
    error "Environment '$ENVIRONMENT' not found. Create it first on GitHub."
  fi
  
  # Encrypt secret (requires libsodium)
  # For now, use GitHub API's public key endpoint
  local public_key_response=$(github_api GET "/environments/$env_id/secrets/public-key")
  local public_key=$(echo "$public_key_response" | jq -r '.key')
  local key_id=$(echo "$public_key_response" | jq -r '.key_id')
  
  # Encrypt value with public key (requires age or libsodium)
  # Simplified: use GitHub API directly (assumes gh cli or similar)
  
  warning "GitHub Secrets API requires encryption. Use GitHub UI or 'gh' CLI for now."
  echo ""
  echo "  gh secret set $key --env $ENVIRONMENT --repo cheapaio/$APP --body \"$value\""
  echo ""
  info "Alternatively, set via GitHub UI:"
  echo "  https://github.com/cheapaio/$APP/settings/environments"
}

cmd_config_get() {
  parse_opts "$@"
  shift $((OPTIND - 1))
  
  local key="$1"
  if [ -z "$key" ]; then
    error "Usage: superdeploy config:get KEY -a APP -e ENV"
  fi
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  warning "GitHub doesn't allow reading secret values via API (security)."
  info "Secret '$key' can only be viewed/edited in GitHub UI:"
  echo "  https://github.com/cheapaio/$APP/settings/environments"
}

cmd_config_list() {
  parse_opts "$@"
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  info "Listing environment secrets for $APP ($ENVIRONMENT)..."
  
  local env_id=$(github_api GET "/environments" | jq -r ".environments[] | select(.name==\"$ENVIRONMENT\") | .id")
  
  if [ -z "$env_id" ] || [ "$env_id" = "null" ]; then
    error "Environment '$ENVIRONMENT' not found"
  fi
  
  github_api GET "/environments/$env_id/secrets" | jq -r '.secrets[] | .name'
}

# =============================================================================
# Deployment Commands
# =============================================================================

cmd_deploy() {
  parse_opts "$@"
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  info "Triggering deployment for $APP ($ENVIRONMENT)..."
  
  # Trigger via Forgejo workflow_dispatch
  local forgejo_url="${FORGEJO_BASE_URL:-http://${CORE_EXTERNAL_IP}:3001}"
  local payload=$(jq -n \
    --arg env "$ENVIRONMENT" \
    --arg app "$APP" \
    '{
      ref: "master",
      inputs: {
        environment: $env,
        services: $app,
        image_tags: "{\"" + $app + "\":\"latest\"}",
        migrate: "false"
      }
    }')
  
  curl -sS -X POST \
    -H "Authorization: token $FORGEJO_PAT" \
    -H "Content-Type: application/json" \
    "${forgejo_url}/api/v1/repos/${FORGEJO_ORG}/superdeploy-app/actions/workflows/deploy.yml/dispatches" \
    -d "$payload" && \
    success "Deployment triggered!" || \
    error "Deployment trigger failed"
  
  echo ""
  info "Check status: ${forgejo_url}/${FORGEJO_ORG}/superdeploy-app/actions"
}

cmd_promote() {
  parse_opts "$@"
  shift $((OPTIND - 1))
  
  local sha="$1"
  if [ -z "$sha" ]; then
    error "Usage: superdeploy promote SHA -a APP"
  fi
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  info "Promoting staging build $sha to production for $APP..."
  
  local forgejo_url="${FORGEJO_BASE_URL:-http://${CORE_EXTERNAL_IP}:3001}"
  local payload=$(jq -n \
    --arg app "$APP" \
    --arg sha "$sha" \
    '{
      ref: "master",
      inputs: {
        environment: "prod",
        services: $app,
        image_tags: "{\"" + $app + "\":\"" + $sha + "\"}",
        migrate: "false"
      }
    }')
  
  curl -sS -X POST \
    -H "Authorization: token $FORGEJO_PAT" \
    -H "Content-Type: application/json" \
    "${forgejo_url}/api/v1/repos/${FORGEJO_ORG}/superdeploy-app/actions/workflows/deploy.yml/dispatches" \
    -d "$payload" && \
    success "Promotion triggered!" || \
    error "Promotion failed"
}

cmd_releases() {
  parse_opts "$@"
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  info "Fetching releases for $APP..."
  
  local forgejo_url="${FORGEJO_BASE_URL:-http://${CORE_EXTERNAL_IP}:3001}"
  
  # Fetch recent workflow runs
  curl -sS \
    -H "Authorization: token $FORGEJO_PAT" \
    "${forgejo_url}/api/v1/repos/${FORGEJO_ORG}/superdeploy-app/actions/runs?limit=20" | \
    jq -r '.workflow_runs[] | select(.name=="Deploy Multi-Service (Reusable)") | "\(.id)\t\(.created_at)\t\(.conclusion // "running")"' | \
    column -t -s $'\t'
}

cmd_rollback() {
  parse_opts "$@"
  shift $((OPTIND - 1))
  
  local version="$1"
  if [ -z "$version" ]; then
    error "Usage: superdeploy rollback VERSION -a APP"
  fi
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  warning "Rollback: Deploy previous image version"
  info "Find version SHA from releases, then run:"
  echo "  superdeploy promote <sha> -a $APP"
}

# =============================================================================
# Runtime Commands
# =============================================================================

cmd_run() {
  local app="$1"
  local command="$2"
  
  if [ -z "$app" ] || [ -z "$command" ]; then
    error "Usage: superdeploy run APP \"COMMAND\""
  fi
  
  info "Running one-off command on $app..."
  
  # SSH into VM and run docker exec
  ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cd /opt/superdeploy/compose && docker compose exec $app $command"
}

cmd_scale() {
  local scale_arg="$1"
  if [ -z "$scale_arg" ]; then
    error "Usage: superdeploy scale APP=REPLICAS"
  fi
  
  local app="${scale_arg%%=*}"
  local replicas="${scale_arg#*=}"
  
  info "Scaling $app to $replicas replicas..."
  
  ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cd /opt/superdeploy/compose && docker compose up -d --scale $app=$replicas"
  
  success "$app scaled to $replicas"
}

cmd_restart() {
  local app="$1"
  if [ -z "$app" ]; then
    error "Usage: superdeploy restart APP"
  fi
  
  info "Restarting $app..."
  
  ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cd /opt/superdeploy/compose && docker compose restart $app"
  
  success "$app restarted"
}

cmd_logs() {
  parse_opts "$@"
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  local follow_flag=""
  if [ "$FOLLOW" = true ]; then
    follow_flag="-f"
  fi
  
  info "Fetching logs for $APP (last $LINES lines)..."
  
  ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cd /opt/superdeploy/compose && docker compose logs $follow_flag --tail=$LINES $APP"
}

# =============================================================================
# Info Commands
# =============================================================================

cmd_apps() {
  info "Available apps:"
  echo "  - api"
  echo "  - dashboard"
  echo "  - services"
}

cmd_info() {
  parse_opts "$@"
  
  if [ -z "$APP" ]; then
    error "App name required (-a APP)"
  fi
  
  info "App info for $APP:"
  
  ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cd /opt/superdeploy/compose && docker compose ps $APP && echo && docker compose images $APP"
}

cmd_status() {
  info "Infrastructure status:"
  echo ""
  echo "Core VM:   ${CORE_EXTERNAL_IP}"
  echo "Scrape VM: ${SCRAPE_EXTERNAL_IP}"
  echo "Proxy VM:  ${PROXY_EXTERNAL_IP}"
  echo ""
  
  info "Services:"
  ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no \
    ${SSH_USER}@${CORE_EXTERNAL_IP} \
    "cd /opt/superdeploy/compose && docker compose ps --format 'table {{.Name}}\t{{.Status}}\t{{.Ports}}'"
}

# =============================================================================
# Main
# =============================================================================

if [ $# -eq 0 ]; then
  usage
  exit 0
fi

COMMAND="$1"
shift

case "$COMMAND" in
  sync)
    cmd_sync "$@"
    ;;
  config:set)
    cmd_config_set "$@"
    ;;
  config:get)
    cmd_config_get "$@"
    ;;
  config:unset)
    warning "Unset not yet implemented. Use GitHub UI."
    ;;
  config)
    cmd_config_list "$@"
    ;;
  deploy)
    cmd_deploy "$@"
    ;;
  promote)
    cmd_promote "$@"
    ;;
  releases)
    cmd_releases "$@"
    ;;
  rollback)
    cmd_rollback "$@"
    ;;
  run)
    cmd_run "$@"
    ;;
  scale)
    cmd_scale "$@"
    ;;
  restart)
    cmd_restart "$@"
    ;;
  logs)
    cmd_logs "$@"
    ;;
  apps)
    cmd_apps
    ;;
  info)
    cmd_info "$@"
    ;;
  status)
    cmd_status
    ;;
  -h|--help)
    usage
    ;;
  *)
    error "Unknown command: $COMMAND. Run 'superdeploy --help' for usage."
    ;;
esac

