# Docker Compose file for {{ project_name }} applications
# Generated by project-deployer role

services:
{% for app_name, app_config in apps.items() %}
  {{ app_name }}:
    image: {{ project_config.docker.registry | default('docker.io') }}/{{ project_config.docker.organization }}/{{ app_name }}:latest
    container_name: {{ project_name }}_{{ app_name }}
    restart: unless-stopped
{% if app_config.port is defined %}
    ports:
      - "{{ app_config.port }}:{{ app_config.port }}"
{% endif %}
    environment:
      - PROJECT_NAME={{ project_name }}
      - APP_NAME={{ app_name }}
{% if app_config.port is defined %}
      - PORT={{ app_config.port }}
{% endif %}
    env_file:
      - {{ project_base_path }}/data/{{ app_name }}/.env
    volumes:
      - {{ project_base_path }}/data/{{ app_name }}:/app/data
      - {{ project_base_path }}/logs/{{ app_name }}:/app/logs
    networks:
      - {{ project_name }}-network
    labels:
      - "com.superdeploy.project={{ project_name }}"
      - "com.superdeploy.app={{ app_name }}"
{% if app_config.port is defined %}
      - "com.superdeploy.port={{ app_config.port }}"
{% endif %}
{% if monitoring_enabled and app_config.port is defined %}
      - "prometheus.scrape=true"
      - "prometheus.port={{ app_config.port }}"
      - "prometheus.path=/metrics"
{% endif %}
    # Healthcheck: Inherited from Dockerfile (no override)
    # Each app defines its own healthcheck in Dockerfile for flexibility
    # RESOURCE LIMITS: Prevent OOM and ensure fair resource sharing
    deploy:
      resources:
        limits:
          memory: {{ app_config.resources.memory | default('512M') }}
          cpus: '{{ app_config.resources.cpu | default('1.0') }}'
        reservations:
          memory: {{ app_config.resources.memory_reservation | default('256M') }}
          cpus: '{{ app_config.resources.cpu_reservation | default('0.5') }}'

{% endfor %}

networks:
  {{ project_name }}-network:
    external: true
