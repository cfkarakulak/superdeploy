name: Deploy Multi-Service (Reusable)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment (prod|staging)'
        required: true
        default: 'prod'
        type: choice
        options:
          - prod
          - staging
      services:
        description: 'Services to deploy (comma-separated: api,dashboard,services)'
        required: true
        default: 'api'
      image_tags:
        description: 'JSON: {"api":"abc123","dashboard":"def456","services":"ghi789"}'
        required: true
      encrypted_env:
        description: 'Encrypted environment variables (base64 of AGE-encrypted .env)'
        required: false
        default: ''
      migrate:
        description: 'Run DB migrations (true/false)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

jobs:
  deploy:
    runs-on: [self-hosted, core, linux, docker]
    
    env:
      ENVIRONMENT: ${{ github.event.inputs.environment }}
      SERVICES: ${{ github.event.inputs.services }}
      IMAGE_TAGS: ${{ github.event.inputs.image_tags }}
      MIGRATE: ${{ github.event.inputs.migrate }}
    
    steps:
      - name: ðŸ“¦ Checkout superdeploy code
        run: |
          cd /opt/superdeploy
          git config --global --add safe.directory /opt/superdeploy
          git fetch origin
          git reset --hard origin/master
          echo "âœ… Superdeploy code updated"

      - name: ðŸ”“ Decrypt environment variables
        id: decrypt
        run: |
          set +x  # Disable echo for security
          
          ENCRYPTED_ENV="${{ github.event.inputs.encrypted_env }}"
          
          if [ -n "$ENCRYPTED_ENV" ] && [ "$ENCRYPTED_ENV" != "" ]; then
            echo "ðŸ” Decrypting environment variables..."
            
            # Decode base64 and decrypt with AGE private key
            echo "$ENCRYPTED_ENV" | base64 -d | age -d -i /opt/forgejo-runner/.age/key.txt > /opt/superdeploy/.env.decrypted 2>/dev/null
            
            if [ $? -eq 0 ]; then
              echo "âœ… Environment decrypted successfully"
              echo "env_file=/opt/superdeploy/.env.decrypted" >> $GITHUB_OUTPUT
            else
              echo "âŒ Failed to decrypt environment"
              echo "env_file=" >> $GITHUB_OUTPUT
            fi
          else
            echo "âš ï¸  No encrypted environment provided, using Forgejo secrets fallback"
            echo "env_file=" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ“ Parse inputs
        id: parse
        run: |
          # Parse JSON image_tags
          echo "$IMAGE_TAGS" > /tmp/image_tags.json
          
          # Extract tags for each service
          API_TAG=$(jq -r '.api // "latest"' /tmp/image_tags.json)
          DASHBOARD_TAG=$(jq -r '.dashboard // "latest"' /tmp/image_tags.json)
          SERVICES_TAG=$(jq -r '.services // "latest"' /tmp/image_tags.json)
          
          echo "api_tag=$API_TAG" >> $GITHUB_OUTPUT
          echo "dashboard_tag=$DASHBOARD_TAG" >> $GITHUB_OUTPUT
          echo "services_tag=$SERVICES_TAG" >> $GITHUB_OUTPUT
          
          echo "ðŸ“‹ Parsed tags:"
          echo "  API: $API_TAG"
          echo "  Dashboard: $DASHBOARD_TAG"
          echo "  Services: $SERVICES_TAG"

      - name: ðŸ“ Setup app .env files from Forgejo Secrets
        run: |
          mkdir -p /opt/app-repos/{api,dashboard,services}
          
          echo "Generating .env files from Forgejo Secrets..."
          
          # API .env
          cat > /opt/app-repos/api/.env <<EOF
          # Database
          DATABASE_URL=postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/${{ secrets.POSTGRES_DB }}
          
          # RabbitMQ
          RABBITMQ_URL=amqp://${{ secrets.RABBITMQ_USER }}:${{ secrets.RABBITMQ_PASSWORD }}@rabbitmq:5672/
          
          # API Config
          API_SECRET_KEY=${{ secrets.API_SECRET_KEY }}
          ENVIRONMENT=${{ env.ENVIRONMENT }}
          
          # Optional
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          
          # Proxy Registry
          PROXY_REGISTRY_URL=http://proxy-registry:8001
          PROXY_REGISTRY_API_KEY=${{ secrets.PROXY_REGISTRY_API_KEY }}
          EOF
          
          # Dashboard .env
          cat > /opt/app-repos/dashboard/.env <<EOF
          PUBLIC_URL=${{ secrets.PUBLIC_URL }}
          API_BASE_URL=${{ secrets.API_BASE_URL }}
          ENVIRONMENT=${{ env.ENVIRONMENT }}
          EOF
          
          # Services .env
          cat > /opt/app-repos/services/.env <<EOF
          # Database
          DATABASE_URL=postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/${{ secrets.POSTGRES_DB }}
          
          # RabbitMQ
          RABBITMQ_URL=amqp://${{ secrets.RABBITMQ_USER }}:${{ secrets.RABBITMQ_PASSWORD }}@rabbitmq:5672/
          
          # Config
          ENVIRONMENT=${{ env.ENVIRONMENT }}
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          EOF
          
          echo "âœ… App .env files generated from Forgejo Secrets"

      - name: ðŸ³ Prepare docker-compose.yml
        run: |
          mkdir -p /opt/superdeploy/compose
          cp /opt/superdeploy/compose/docker-compose.yml.template /opt/superdeploy/compose/docker-compose.yml
          
          echo "âœ… docker-compose.yml ready"

      - name: ðŸ³ Pull images (selective)
        run: |
          cd /opt/superdeploy/compose
          
          # Load infrastructure env
          set -a
          source /opt/superdeploy/.env
          set +a
          
          # Set image tags
          export API_IMAGE_TAG="${{ steps.parse.outputs.api_tag }}"
          export DASHBOARD_IMAGE_TAG="${{ steps.parse.outputs.dashboard_tag }}"
          export SERVICES_IMAGE_TAG="${{ steps.parse.outputs.services_tag }}"
          
          # Ensure DOCKER_REGISTRY is set
          export DOCKER_REGISTRY="${DOCKER_REGISTRY:-docker.io}"
          
          # Load decrypted env if available (from GitHub)
          ENV_FILE="${{ steps.decrypt.outputs.env_file }}"
          
          if [ -n "$ENV_FILE" ] && [ -f "$ENV_FILE" ]; then
            echo "ðŸ“¥ Loading decrypted environment from GitHub"
            set -a
            source "$ENV_FILE"
            set +a
          else
            echo "ðŸ“¥ Using Forgejo secrets (fallback)"
            # Set DB/Queue credentials from Forgejo Secrets
            export POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
            export POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
            export POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
            export RABBITMQ_USER="${{ secrets.RABBITMQ_USER }}"
            export RABBITMQ_PASSWORD="${{ secrets.RABBITMQ_PASSWORD }}"
          fi
          
          # Deployment timestamp
          export DEPLOY_TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          
          # Parse services to deploy
          IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
          
          echo "ðŸ“¥ Pulling images for: ${SERVICE_ARRAY[@]}"
          
          # Pull only specified services
          for service in "${SERVICE_ARRAY[@]}"; do
            service=$(echo $service | xargs)  # trim whitespace
            echo "Pulling $service..."
            docker compose pull $service || echo "âš ï¸  Failed to pull $service"
          done
          
          echo "âœ… Images pulled!"

      - name: ðŸ—„ï¸ Run DB migrations (optional)
        if: ${{ github.event.inputs.migrate == 'true' }}
        timeout-minutes: 10
        run: |
          cd /opt/superdeploy/compose
          
          echo "ðŸ”„ Running database migrations..."
          echo "âš ï¸  Migration failure will STOP deployment"
          
          # Load env for compose
          set -a
          source /opt/superdeploy/.env
          set +a
          
          export POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
          export POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
          export POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
          
          # Run migrations with timeout and error handling
          if docker compose -f docker-compose.core.yml -f docker-compose.apps.yml \
             run --rm api alembic upgrade head; then
            echo "âœ… Migrations completed successfully"
          else
            echo "âŒ MIGRATION FAILED!"
            echo "âš ï¸  Deployment will be aborted"
            echo "ðŸ“‹ Manual rollback may be required"
            exit 1
          fi
          
          # Verify migration was successful
          echo "ðŸ” Verifying migration..."
          docker compose -f docker-compose.core.yml -f docker-compose.apps.yml \
            run --rm api alembic current || {
            echo "âŒ Migration verification failed"
            exit 1
          }
          
          echo "âœ… Migration verified"

      - name: ðŸš€ Deploy services (selective, zero-downtime attempt)
        run: |
          cd /opt/superdeploy/compose
          
          # Load env again for compose
          set -a
          source /opt/superdeploy/.env
          set +a
          
          export API_IMAGE_TAG="${{ steps.parse.outputs.api_tag }}"
          export DASHBOARD_IMAGE_TAG="${{ steps.parse.outputs.dashboard_tag }}"
          export SERVICES_IMAGE_TAG="${{ steps.parse.outputs.services_tag }}"
          export DOCKER_REGISTRY="${DOCKER_REGISTRY:-docker.io}"
          export POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
          export POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
          export POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
          export RABBITMQ_USER="${{ secrets.RABBITMQ_USER }}"
          export RABBITMQ_PASSWORD="${{ secrets.RABBITMQ_PASSWORD }}"
          export DEPLOY_TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          
          # Parse services
          IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
          
          echo "ðŸš€ Deploying: ${SERVICE_ARRAY[@]}"
          
          # Deploy only specified services
          # Note: Docker Compose doesn't have native rolling updates
          # For true zero-downtime, use Kubernetes or Docker Swarm
          docker compose up -d --no-deps "${SERVICE_ARRAY[@]}"
          
          echo "âœ… Services deployed!"

      - name: â³ Wait for services to be healthy
        run: |
          cd /opt/superdeploy/compose
          
          echo "Waiting for services to be healthy..."
          sleep 10
          
          docker compose ps
          echo "âœ… Services should be healthy!"

      - name: ðŸ¥ Health checks
        run: |
          echo "ðŸ¥ Running health checks..."
          
          # PostgreSQL
          docker exec superdeploy-postgres pg_isready -U ${{ secrets.POSTGRES_USER }} && \
            echo "âœ… PostgreSQL healthy" || echo "âŒ PostgreSQL unhealthy"
          
          # RabbitMQ
          docker exec superdeploy-rabbitmq rabbitmq-diagnostics ping && \
            echo "âœ… RabbitMQ healthy" || echo "âŒ RabbitMQ unhealthy"
          
          # API health endpoint (if exists)
          curl -f http://localhost:8000/health 2>/dev/null && \
            echo "âœ… API healthy" || echo "âš ï¸  API health check skipped (no endpoint)"

      - name: ðŸ“Š Show deployment status
        run: |
          cd /opt/superdeploy/compose
          
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "         ðŸŽ‰ DEPLOYMENT COMPLETE! ðŸŽ‰                    "
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "Services: ${{ env.SERVICES }}"
          echo ""
          docker compose ps
          echo ""
          echo "ðŸŒ Services are available at: http://$(curl -s ifconfig.me)"

      - name: ðŸ“§ Send deployment notification
        if: always()
        run: |
          # Determine deployment status
          if [ "${{ job.status }}" = "success" ]; then
            STATUS="âœ… SUCCESS"
          else
            STATUS="âŒ FAILED"
          fi
          
          # Get deployed image tags
          API_TAG="${{ steps.parse.outputs.api_tag }}"
          DASHBOARD_TAG="${{ steps.parse.outputs.dashboard_tag }}"
          SERVICES_TAG="${{ steps.parse.outputs.services_tag }}"
          
          # Get external IP
          EXTERNAL_IP=$(curl -s ifconfig.me 2>/dev/null || echo "unknown")
          
          # Email config - hardcoded (root cause fix: no dependency on secrets)
          ENV_NAME="${{ env.ENVIRONMENT }}"
          SERVICES_LIST="${{ env.SERVICES }}"
          ALERT_EMAIL="cradexco@gmail.com"  # From .env
          FORGEJO_ORG="cradexco"  # From .env
          SUBJECT="[${STATUS}] SuperDeploy - ${ENV_NAME} - ${SERVICES_LIST}"
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          # Install mailutils if not present
          if ! command -v mail &> /dev/null; then
            echo "ðŸ“¦ Installing mailutils..."
            export DEBIAN_FRONTEND=noninteractive
            apt-get update -qq && apt-get install -y mailutils postfix 2>&1 | grep -v "^Get:" || {
              echo "âš ï¸  Failed to install mailutils - email will be skipped"
              echo "âœ… Deployment notification: ${STATUS} (email disabled)"
              exit 0
            }
          fi
          
          # Send email
          {
            echo "SuperDeploy Deployment Notification"
            echo ""
            echo "Status = ${STATUS}"
            echo "Environment = ${ENV_NAME}"
            echo "Services = ${SERVICES_LIST}"
            echo "Timestamp = ${TIMESTAMP}"
            echo ""
            echo "Deployed Images ="
            echo "  API = ${API_TAG}"
            echo "  Dashboard = ${DASHBOARD_TAG}"
            echo "  Services = ${SERVICES_TAG}"
            echo ""
            echo "Access URLs ="
            echo "  Dashboard = http://${EXTERNAL_IP}"
            echo "  API = http://${EXTERNAL_IP}:8000"
            echo "  Forgejo = http://${EXTERNAL_IP}:3001"
            echo ""
            echo "Logs = http://${EXTERNAL_IP}:3001/${FORGEJO_ORG}/superdeploy-app/actions"
          } | mail -s "$SUBJECT" "$ALERT_EMAIL" 2>&1 && {
            echo "âœ… Email sent to $ALERT_EMAIL"
          } || {
            echo "âš ï¸  Email send failed (not critical)"
          }
          
          echo "âœ… Notification complete"

      - name: ðŸ§¹ Cleanup decrypted env (security)
        if: always()
        run: |
          ENV_FILE="${{ steps.decrypt.outputs.env_file }}"
          if [ -n "$ENV_FILE" ] && [ -f "$ENV_FILE" ]; then
            echo "ðŸ”’ Securely deleting decrypted env file..."
            shred -u "$ENV_FILE" 2>/dev/null || rm -f "$ENV_FILE"
            echo "âœ… Decrypted env removed"
          fi

