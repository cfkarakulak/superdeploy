name: Deploy Service

on:
  workflow_dispatch:
    inputs:
      project:
        description: 'Project name (e.g., cheapa, myapp)'
        required: true
        type: string
      service:
        description: 'Service name (e.g., api, dashboard, services)'
        required: true
        type: string
      image:
        description: 'Docker image with tag (e.g., ghcr.io/cheapaio/api:abc123)'
        required: true
        type: string
      env_bundle:
        description: 'AGE-encrypted environment variables bundle'
        required: true
        type: string
      git_sha:
        description: 'Git commit SHA (for tracking)'
        required: true
        type: string
      git_ref:
        description: 'Git ref (branch/tag)'
        required: false
        default: 'production'
        type: string

jobs:
  deploy:
    runs-on: [self-hosted, linux]
    
    env:
      PROJECT: ${{ inputs.project }}
      SERVICE: ${{ inputs.service }}
      IMAGE: ${{ inputs.image }}
      ENV_BUNDLE: ${{ inputs.env_bundle }}
      GIT_SHA: ${{ inputs.git_sha }}
      GIT_REF: ${{ inputs.git_ref }}
    
    steps:
      - name: Checkout superdeploy repo
        uses: actions/checkout@v4
      
      - name: Decrypt environment bundle
        id: decrypt
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üîê Decrypting environment bundle..."
          echo "${{ env.ENV_BUNDLE }}" | base64 -d > /tmp/encrypted.age
          echo "‚úÖ Base64 decoded successfully"
          
          age -d -i /opt/forgejo-runner/.age/key.txt /tmp/encrypted.age > /tmp/decrypted.env
          echo "‚úÖ AGE decryption successful"
          
          echo "üìã Decrypted env file contents (first 5 lines, masked):"
          head -5 /tmp/decrypted.env | sed 's/=.*/=***MASKED***/g'
          
          rm /tmp/encrypted.age
          echo "env_file=/tmp/decrypted.env" >> $GITHUB_OUTPUT
          echo "‚úÖ Decrypt step completed"
      
      - name: Load environment variables
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üì• Loading environment variables..."
          
          set -a
          source /tmp/decrypted.env
          set +a
          
          echo "‚úÖ Environment sourced successfully"
          
          # Save to GitHub env for next steps (filter out comments and empty lines)
          grep -v '^#' /tmp/decrypted.env | grep -v '^$' >> $GITHUB_ENV
          
          echo "üìä Total env vars loaded: $(grep -v '^#' /tmp/decrypted.env | grep -v '^$' | wc -l)"
          echo "‚úÖ Load env step completed"
      
      - name: Login to Docker Hub
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üê≥ Logging in to Docker Hub..."
          
          # Login using Docker Hub credentials from Forgejo secrets
          echo "${{ secrets.DOCKER_TOKEN }}" | docker login docker.io -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          
          echo "‚úÖ Docker Hub login successful"
      
      - name: Generate docker-compose for service
        run: |
          mkdir -p /opt/apps/${{ env.PROJECT }}/compose
          
          # Generate compose file from template
          cat > /opt/apps/${{ env.PROJECT }}/compose/docker-compose-${{ env.SERVICE }}.yml <<'EOF'
          version: '3.8'
          
          networks:
            PROJECT_NETWORK:
              external: true
          
          services:
            SERVICE_NAME:
              image: IMAGE_PLACEHOLDER
              container_name: CONTAINER_NAME
              restart: unless-stopped
              networks:
                - PROJECT_NETWORK
              ports:
                - "PORT_PLACEHOLDER:INTERNAL_PORT_PLACEHOLDER"
              env_file:
                - /tmp/decrypted.env
              labels:
                com.superdeploy.project: "PROJECT_PLACEHOLDER"
                com.superdeploy.service: "SERVICE_PLACEHOLDER"
                com.superdeploy.git.sha: "GIT_SHA_PLACEHOLDER"
                com.superdeploy.git.ref: "GIT_REF_PLACEHOLDER"
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:INTERNAL_PORT_PLACEHOLDER/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          EOF
          
          # Determine port mapping based on service type
          case "${{ env.SERVICE }}" in
            api)
              EXTERNAL_PORT=8000
              INTERNAL_PORT=8000
              ;;
            dashboard)
              EXTERNAL_PORT=80
              INTERNAL_PORT=3000
              ;;
            services)
              EXTERNAL_PORT=9000
              INTERNAL_PORT=8000
              ;;
            *)
              EXTERNAL_PORT=8080
              INTERNAL_PORT=8080
              ;;
          esac
          
          # Replace placeholders (using @ as delimiter to avoid conflicts)
          COMPOSE_FILE="/opt/apps/${{ env.PROJECT }}/compose/docker-compose-${{ env.SERVICE }}.yml"
          
          sed -i "s@PROJECT_NETWORK@${{ env.PROJECT }}-network@g" "$COMPOSE_FILE"
          sed -i "s@SERVICE_NAME@${{ env.PROJECT }}-${{ env.SERVICE }}@g" "$COMPOSE_FILE"
          sed -i "s@CONTAINER_NAME@${{ env.PROJECT }}-${{ env.SERVICE }}@g" "$COMPOSE_FILE"
          sed -i "s@IMAGE_PLACEHOLDER@${{ env.IMAGE }}@g" "$COMPOSE_FILE"
          sed -i "s@PROJECT_PLACEHOLDER@${{ env.PROJECT }}@g" "$COMPOSE_FILE"
          sed -i "s@SERVICE_PLACEHOLDER@${{ env.SERVICE }}@g" "$COMPOSE_FILE"
          sed -i "s@GIT_SHA_PLACEHOLDER@${{ env.GIT_SHA }}@g" "$COMPOSE_FILE"
          sed -i "s@GIT_REF_PLACEHOLDER@${{ env.GIT_REF }}@g" "$COMPOSE_FILE"
          sed -i "s@PORT_PLACEHOLDER@${EXTERNAL_PORT}@g" "$COMPOSE_FILE"
          sed -i "s@INTERNAL_PORT_PLACEHOLDER@${INTERNAL_PORT}@g" "$COMPOSE_FILE"
          
          echo "‚úÖ Generated compose file with ports: ${EXTERNAL_PORT}:${INTERNAL_PORT}"
      
      - name: Deploy core services first
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üîß Checking for core services..."
          
          # Deploy core services (PostgreSQL, RabbitMQ, Redis) if not running
          CORE_COMPOSE="/opt/superdeploy/projects/${{ env.PROJECT }}/compose/docker-compose.core.yml"
          
          if [ -f "$CORE_COMPOSE" ]; then
            echo "üì¶ Deploying core services (PostgreSQL, RabbitMQ, Redis)..."
            cd /opt/superdeploy/projects/${{ env.PROJECT }}/compose
            
            echo "üìÇ Current directory: $(pwd)"
            echo "üìã Files in directory:"
            ls -la
            
            # Load environment variables from decrypted file (skip comments and empty lines)
            export $(grep -v '^#' /tmp/decrypted.env | grep -v '^$' | xargs)
            
            echo "üê≥ Starting core services..."
            # Deploy core services
            docker compose -f docker-compose.core.yml up -d --wait
            
            echo "üìä Core services status:"
            docker compose -f docker-compose.core.yml ps
            
            echo "‚úÖ Core services deployed!"
          else
            echo "‚ö†Ô∏è  No core services compose file found at: $CORE_COMPOSE"
            echo "üìÇ Listing /opt/superdeploy/projects/${{ env.PROJECT }}:"
            ls -la /opt/superdeploy/projects/${{ env.PROJECT }}/ || echo "Directory not found"
          fi
      
      - name: Deploy service
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üöÄ Deploying service: ${{ env.SERVICE }}"
          
          cd /opt/apps/${{ env.PROJECT }}/compose
          
          echo "üìÇ Current directory: $(pwd)"
          echo "üìã Compose file:"
          cat docker-compose-${{ env.SERVICE }}.yml
          
          # Create project network if it doesn't exist
          echo "üåê Creating/checking network: ${{ env.PROJECT }}-network"
          docker network create ${{ env.PROJECT }}-network 2>/dev/null || echo "Network already exists"
          
          # Pull latest image
          echo "üì• Pulling image: ${{ env.IMAGE }}"
          docker pull ${{ env.IMAGE }}
          
          # Deploy with zero-downtime
          echo "üê≥ Starting service container..."
          docker compose -f docker-compose-${{ env.SERVICE }}.yml up -d --wait
          
          echo "üìä Container status:"
          docker ps -a --filter "name=${{ env.PROJECT }}-${{ env.SERVICE }}"
          
          # Wait for health check
          echo "üè• Waiting for health check..."
          timeout 120 bash -c 'until docker inspect --format="{{.State.Health.Status}}" ${{ env.PROJECT }}-${{ env.SERVICE }} | grep -q "healthy"; do echo "Waiting for health check... ($(docker inspect --format="{{.State.Health.Status}}" ${{ env.PROJECT }}-${{ env.SERVICE }}))"; sleep 2; done' || {
            echo "‚ùå Health check failed!"
            echo "üìã Container logs (last 100 lines):"
            docker logs ${{ env.PROJECT }}-${{ env.SERVICE }} --tail 100
            echo "üìä Container inspect:"
            docker inspect ${{ env.PROJECT }}-${{ env.SERVICE }}
            exit 1
          }
          
          echo "‚úÖ Service deployed and healthy!"
      
      - name: Cleanup old images
        run: |
          # Keep last 3 images
          docker images ghcr.io/*/${{ env.SERVICE }} --format "{{.ID}}" | tail -n +4 | xargs -r docker rmi || true
      
      - name: Clean up secrets
        if: always()
        run: |
          rm -f /tmp/decrypted.env
          rm -f /tmp/encrypted.age
      
      - name: Send notification
        if: always()
        run: |
          STATUS="${{ job.status }}"
          if [ "$STATUS" == "success" ]; then
            EMOJI="‚úÖ"
            COLOR="good"
          else
            EMOJI="‚ùå"
            COLOR="danger"
          fi
          
          # Send email notification
          echo "Deployment $STATUS: ${{ env.PROJECT }}/${{ env.SERVICE }} @ ${{ env.GIT_SHA }}" | \
            mail -s "[$EMOJI] Deployment $STATUS" $ALERT_EMAIL || true
