name: Deploy Multi-Service (Reusable)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment (prod|staging)'
        required: true
        default: 'prod'
        type: choice
        options:
          - prod
          - staging
      services:
        description: 'Services to deploy (comma-separated: api,dashboard,services)'
        required: true
        default: 'api'
      image_tags:
        description: 'JSON: {"api":"abc123","dashboard":"def456","services":"ghi789"}'
        required: true
      migrate:
        description: 'Run DB migrations (true/false)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

jobs:
  deploy:
    runs-on: [self-hosted, core, linux, docker]
    
    env:
      ENVIRONMENT: ${{ github.event.inputs.environment }}
      SERVICES: ${{ github.event.inputs.services }}
      IMAGE_TAGS: ${{ github.event.inputs.image_tags }}
      MIGRATE: ${{ github.event.inputs.migrate }}
    
    steps:
      - name: üì¶ Checkout superdeploy code
        run: |
          cd /opt/superdeploy
          git config --global --add safe.directory /opt/superdeploy
          git fetch origin
          git reset --hard origin/master
          echo "‚úÖ Superdeploy code updated"

      - name: üìù Parse inputs
        id: parse
        run: |
          # Parse JSON image_tags
          echo "$IMAGE_TAGS" > /tmp/image_tags.json
          
          # Extract tags for each service
          API_TAG=$(jq -r '.api // "latest"' /tmp/image_tags.json)
          DASHBOARD_TAG=$(jq -r '.dashboard // "latest"' /tmp/image_tags.json)
          SERVICES_TAG=$(jq -r '.services // "latest"' /tmp/image_tags.json)
          
          echo "api_tag=$API_TAG" >> $GITHUB_OUTPUT
          echo "dashboard_tag=$DASHBOARD_TAG" >> $GITHUB_OUTPUT
          echo "services_tag=$SERVICES_TAG" >> $GITHUB_OUTPUT
          
          echo "üìã Parsed tags:"
          echo "  API: $API_TAG"
          echo "  Dashboard: $DASHBOARD_TAG"
          echo "  Services: $SERVICES_TAG"

      - name: üìù Setup app .env files from Forgejo Secrets
        run: |
          mkdir -p /opt/app-repos/{api,dashboard,services}
          
          echo "Generating .env files from Forgejo Secrets..."
          
          # API .env
          cat > /opt/app-repos/api/.env <<EOF
          # Database
          DATABASE_URL=postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/${{ secrets.POSTGRES_DB }}
          
          # RabbitMQ
          RABBITMQ_URL=amqp://${{ secrets.RABBITMQ_USER }}:${{ secrets.RABBITMQ_PASSWORD }}@rabbitmq:5672/
          
          # API Config
          API_SECRET_KEY=${{ secrets.API_SECRET_KEY }}
          ENVIRONMENT=${{ env.ENVIRONMENT }}
          
          # Optional
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          
          # Proxy Registry
          PROXY_REGISTRY_URL=http://proxy-registry:8001
          PROXY_REGISTRY_API_KEY=${{ secrets.PROXY_REGISTRY_API_KEY }}
          EOF
          
          # Dashboard .env
          cat > /opt/app-repos/dashboard/.env <<EOF
          PUBLIC_URL=${{ secrets.PUBLIC_URL }}
          API_BASE_URL=${{ secrets.API_BASE_URL }}
          ENVIRONMENT=${{ env.ENVIRONMENT }}
          EOF
          
          # Services .env
          cat > /opt/app-repos/services/.env <<EOF
          # Database
          DATABASE_URL=postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/${{ secrets.POSTGRES_DB }}
          
          # RabbitMQ
          RABBITMQ_URL=amqp://${{ secrets.RABBITMQ_USER }}:${{ secrets.RABBITMQ_PASSWORD }}@rabbitmq:5672/
          
          # Config
          ENVIRONMENT=${{ env.ENVIRONMENT }}
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          EOF
          
          echo "‚úÖ App .env files generated from Forgejo Secrets"

      - name: üê≥ Prepare docker-compose.yml
        run: |
          mkdir -p /opt/superdeploy/compose
          cp /opt/superdeploy/compose/docker-compose.yml.template /opt/superdeploy/compose/docker-compose.yml
          
          echo "‚úÖ docker-compose.yml ready"

      - name: üê≥ Pull images (selective)
        run: |
          cd /opt/superdeploy/compose
          
          # Load infrastructure env
          set -a
          source /opt/superdeploy/.env
          set +a
          
          # Set image tags
          export API_IMAGE_TAG="${{ steps.parse.outputs.api_tag }}"
          export DASHBOARD_IMAGE_TAG="${{ steps.parse.outputs.dashboard_tag }}"
          export SERVICES_IMAGE_TAG="${{ steps.parse.outputs.services_tag }}"
          
          # Ensure DOCKER_REGISTRY is set
          export DOCKER_REGISTRY="${DOCKER_REGISTRY:-docker.io}"
          
          # Set DB/Queue credentials from Forgejo Secrets
          export POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
          export POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
          export POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
          export RABBITMQ_USER="${{ secrets.RABBITMQ_USER }}"
          export RABBITMQ_PASSWORD="${{ secrets.RABBITMQ_PASSWORD }}"
          
          # Deployment timestamp
          export DEPLOY_TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          
          # Parse services to deploy
          IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
          
          echo "üì• Pulling images for: ${SERVICE_ARRAY[@]}"
          
          # Pull only specified services
          for service in "${SERVICE_ARRAY[@]}"; do
            service=$(echo $service | xargs)  # trim whitespace
            echo "Pulling $service..."
            docker compose pull $service || echo "‚ö†Ô∏è  Failed to pull $service"
          done
          
          echo "‚úÖ Images pulled!"

      - name: üóÑÔ∏è Run DB migrations (optional)
        if: ${{ github.event.inputs.migrate == 'true' }}
        timeout-minutes: 10
        run: |
          cd /opt/superdeploy/compose
          
          echo "üîÑ Running database migrations..."
          echo "‚ö†Ô∏è  Migration failure will STOP deployment"
          
          # Load env for compose
          set -a
          source /opt/superdeploy/.env
          set +a
          
          export POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
          export POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
          export POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
          
          # Run migrations with timeout and error handling
          if docker compose -f docker-compose.core.yml -f docker-compose.apps.yml \
             run --rm api alembic upgrade head; then
            echo "‚úÖ Migrations completed successfully"
          else
            echo "‚ùå MIGRATION FAILED!"
            echo "‚ö†Ô∏è  Deployment will be aborted"
            echo "üìã Manual rollback may be required"
            exit 1
          fi
          
          # Verify migration was successful
          echo "üîç Verifying migration..."
          docker compose -f docker-compose.core.yml -f docker-compose.apps.yml \
            run --rm api alembic current || {
            echo "‚ùå Migration verification failed"
            exit 1
          }
          
          echo "‚úÖ Migration verified"

      - name: üöÄ Deploy services (selective, zero-downtime attempt)
        run: |
          cd /opt/superdeploy/compose
          
          # Load env again for compose
          set -a
          source /opt/superdeploy/.env
          set +a
          
          export API_IMAGE_TAG="${{ steps.parse.outputs.api_tag }}"
          export DASHBOARD_IMAGE_TAG="${{ steps.parse.outputs.dashboard_tag }}"
          export SERVICES_IMAGE_TAG="${{ steps.parse.outputs.services_tag }}"
          export DOCKER_REGISTRY="${DOCKER_REGISTRY:-docker.io}"
          export POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
          export POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
          export POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
          export RABBITMQ_USER="${{ secrets.RABBITMQ_USER }}"
          export RABBITMQ_PASSWORD="${{ secrets.RABBITMQ_PASSWORD }}"
          export DEPLOY_TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          
          # Parse services
          IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
          
          echo "üöÄ Deploying: ${SERVICE_ARRAY[@]}"
          
          # Deploy only specified services
          # Note: Docker Compose doesn't have native rolling updates
          # For true zero-downtime, use Kubernetes or Docker Swarm
          docker compose up -d --no-deps "${SERVICE_ARRAY[@]}"
          
          echo "‚úÖ Services deployed!"

      - name: ‚è≥ Wait for services to be healthy
        run: |
          cd /opt/superdeploy/compose
          
          echo "Waiting for services to be healthy..."
          sleep 10
          
          docker compose ps
          echo "‚úÖ Services should be healthy!"

      - name: üè• Health checks
        run: |
          echo "üè• Running health checks..."
          
          # PostgreSQL
          docker exec superdeploy-postgres pg_isready -U ${{ secrets.POSTGRES_USER }} && \
            echo "‚úÖ PostgreSQL healthy" || echo "‚ùå PostgreSQL unhealthy"
          
          # RabbitMQ
          docker exec superdeploy-rabbitmq rabbitmq-diagnostics ping && \
            echo "‚úÖ RabbitMQ healthy" || echo "‚ùå RabbitMQ unhealthy"
          
          # API health endpoint (if exists)
          curl -f http://localhost:8000/health 2>/dev/null && \
            echo "‚úÖ API healthy" || echo "‚ö†Ô∏è  API health check skipped (no endpoint)"

      - name: üìä Show deployment status
        run: |
          cd /opt/superdeploy/compose
          
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "         üéâ DEPLOYMENT COMPLETE! üéâ                    "
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo ""
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "Services: ${{ env.SERVICES }}"
          echo ""
          docker compose ps
          echo ""
          echo "üåê Services are available at: http://$(curl -s ifconfig.me)"

      - name: üìß Send deployment notification
        if: always()
        run: |
          # Determine deployment status
          if [ "${{ job.status }}" = "success" ]; then
            STATUS="‚úÖ SUCCESS"
          else
            STATUS="‚ùå FAILED"
          fi
          
          # Get deployed image tags
          API_TAG="${{ steps.parse.outputs.api_tag }}"
          DASHBOARD_TAG="${{ steps.parse.outputs.dashboard_tag }}"
          SERVICES_TAG="${{ steps.parse.outputs.services_tag }}"
          
          # Get external IP
          EXTERNAL_IP=$(curl -s ifconfig.me 2>/dev/null || echo "unknown")
          
          # Send email via mailx (if available)
          ENV_NAME="${{ env.ENVIRONMENT }}"
          SERVICES_LIST="${{ env.SERVICES }}"
          ALERT_EMAIL="${{ secrets.ALERT_EMAIL }}"
          FORGEJO_ORG="${{ secrets.FORGEJO_ORG }}"
          SUBJECT="[${STATUS}] SuperDeploy - ${ENV_NAME} - ${SERVICES_LIST}"
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          if command -v mail &> /dev/null; then
            {
              echo "SuperDeploy Deployment Notification"
              echo ""
              echo "Status = ${STATUS}"
              echo "Environment = ${ENV_NAME}"
              echo "Services = ${SERVICES_LIST}"
              echo "Timestamp = ${TIMESTAMP}"
              echo ""
              echo "Deployed Images ="
              echo "  API = ${API_TAG}"
              echo "  Dashboard = ${DASHBOARD_TAG}"
              echo "  Services = ${SERVICES_TAG}"
              echo ""
              echo "Access URLs ="
              echo "  Dashboard = http://${EXTERNAL_IP}"
              echo "  API = http://${EXTERNAL_IP}:8000"
              echo "  Forgejo = http://${EXTERNAL_IP}:3001"
              echo ""
              echo "Logs = http://${EXTERNAL_IP}:3001/${FORGEJO_ORG}/superdeploy-app/actions"
            } | mail -s "$SUBJECT" "$ALERT_EMAIL"
            echo "üìß Email sent to $ALERT_EMAIL"
          else
            echo "‚ö†Ô∏è  'mail' command not found"
          fi

