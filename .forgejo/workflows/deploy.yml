name: Deploy Service

on:
  workflow_dispatch:
    inputs:
      project:
        description: 'Project name (e.g., cheapa, myapp)'
        required: true
        type: string
      service:
        description: 'Service name (e.g., api, dashboard, services)'
        required: true
        type: string
      image:
        description: 'Docker image with tag (e.g., ghcr.io/cheapaio/api:abc123)'
        required: true
        type: string
      env_bundle:
        description: 'AGE-encrypted environment variables bundle'
        required: true
        type: string
      git_sha:
        description: 'Git commit SHA (for tracking)'
        required: true
        type: string
      git_ref:
        description: 'Git ref (branch/tag)'
        required: false
        default: 'production'
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    env:
      PROJECT: ${{ inputs.project }}
      SERVICE: ${{ inputs.service }}
      IMAGE: ${{ inputs.image }}
      ENV_BUNDLE: ${{ inputs.env_bundle }}
      GIT_SHA: ${{ inputs.git_sha }}
      GIT_REF: ${{ inputs.git_ref }}
    
    steps:
      - name: Checkout superdeploy repo
        uses: actions/checkout@v4
      
      - name: Install dependencies
        run: |
          # Install age
          curl -sL https://github.com/FiloSottile/age/releases/download/v1.1.1/age-v1.1.1-linux-amd64.tar.gz | tar xz
          mv age/age /usr/local/bin/
          rm -rf age
          
          # Install docker-compose
          curl -sL "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          chmod +x /usr/local/bin/docker-compose
          docker-compose version
      
      - name: Decrypt environment bundle
        id: decrypt
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üîê Decrypting environment bundle..."
          echo "${{ env.ENV_BUNDLE }}" | base64 -d > /tmp/encrypted.age
          echo "‚úÖ Base64 decoded successfully"
          
          echo "${{ secrets.AGE_SECRET_KEY }}" > /tmp/age-key.txt
          age -d -i /tmp/age-key.txt /tmp/encrypted.age > /tmp/decrypted.env
          rm /tmp/age-key.txt
          echo "‚úÖ AGE decryption successful"
          
          echo "üìã Decrypted env file contents (first 5 lines, masked):"
          head -5 /tmp/decrypted.env | sed 's/=.*/=***MASKED***/g'
          
          rm /tmp/encrypted.age
          echo "env_file=/tmp/decrypted.env" >> $GITHUB_OUTPUT
          echo "‚úÖ Decrypt step completed"
      
      - name: Load environment variables
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üì• Loading environment variables..."
          
          # Check if decrypted env file exists
          if [ ! -f /tmp/decrypted.env ]; then
            echo "‚ùå Decrypted env file not found!"
            exit 1
          fi
          
          # Check if file is not empty
          if [ ! -s /tmp/decrypted.env ]; then
            echo "‚ùå Decrypted env file is empty!"
            exit 1
          fi
          
          set -a
          source /tmp/decrypted.env
          set +a
          
          echo "‚úÖ Environment sourced successfully"
          
          # Save to GitHub env for next steps (filter out comments and empty lines)
          grep -v '^#' /tmp/decrypted.env | grep -v '^$' >> $GITHUB_ENV
          
          echo "üìä Total env vars loaded: $(grep -v '^#' /tmp/decrypted.env | grep -v '^$' | wc -l)"
          echo "‚úÖ Load env step completed"
      
      - name: Login to Docker Hub
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üê≥ Logging in to Docker Hub..."
          
          # Check if credentials exist
          if [ -z "${{ secrets.DOCKER_USERNAME }}" ] || [ -z "${{ secrets.DOCKER_TOKEN }}" ]; then
            echo "‚ùå Docker Hub credentials not found in secrets!"
            exit 1
          fi
          
          # Login using Docker Hub credentials from Forgejo secrets
          echo "${{ secrets.DOCKER_TOKEN }}" | docker login docker.io -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Docker Hub login successful"
          else
            echo "‚ùå Docker Hub login failed!"
            exit 1
          fi
      
      - name: Load project configuration
        id: config
        run: |
          set -ex
          echo "üìã Loading project configuration..."
          
          # We're running inside a container, but project.yml is on the host
          # Copy it from the host using docker cp (we have docker socket access)
          CONFIG_FILE="/tmp/project.yml"
          
          # Find the current container ID
          HOSTNAME=$(hostname)
          echo "üîç Running in container: $HOSTNAME"
          
          # Use docker exec to cat the file from host context
          # The runner has access to docker socket, so we can access host filesystem
          docker run --rm -v /opt/superdeploy/projects/${{ env.PROJECT }}:/project:ro alpine cat /project/project.yml > "$CONFIG_FILE" || {
            echo "‚ùå ERROR: Cannot access project.yml from host"
            echo "Tried to mount: /opt/superdeploy/projects/${{ env.PROJECT }}/project.yml"
            exit 1
          }
          
          echo "‚úÖ Successfully loaded project.yml from host"
          
          if [ -f "$CONFIG_FILE" ]; then
            # Use helper script to parse YAML config
            PARSER_SCRIPT="${GITHUB_WORKSPACE}/.forgejo/scripts/parse_config.py"
            
            echo "üîç Debug: CONFIG_FILE=$CONFIG_FILE"
            echo "üîç Debug: PARSER_SCRIPT=$PARSER_SCRIPT"
            echo "üîç Debug: SERVICE=${{ env.SERVICE }}"
            echo "üîç Debug: GITHUB_WORKSPACE=$GITHUB_WORKSPACE"
            
            if [ -f "$PARSER_SCRIPT" ]; then
              echo "‚úÖ Parser script found"
              PORTS_OUTPUT=$(python3 "$PARSER_SCRIPT" "$CONFIG_FILE" "${{ env.SERVICE }}" 2>&1)
              echo "üîç Debug: PORTS_OUTPUT='$PORTS_OUTPUT'"
              
              read EXTERNAL_PORT INTERNAL_PORT <<< "$PORTS_OUTPUT"
              
              echo "üîç Debug: EXTERNAL_PORT='$EXTERNAL_PORT'"
              echo "üîç Debug: INTERNAL_PORT='$INTERNAL_PORT'"
              
              # NO FALLBACK! Fail if ports are empty
              if [ -z "$EXTERNAL_PORT" ] || [ -z "$INTERNAL_PORT" ]; then
                echo "‚ùå ERROR: Failed to parse ports from project.yml!"
                echo "Project file: $CONFIG_FILE"
                echo "Service: ${{ env.SERVICE }}"
                exit 1
              fi
              
              echo "external_port=${EXTERNAL_PORT}" >> $GITHUB_OUTPUT
              echo "internal_port=${INTERNAL_PORT}" >> $GITHUB_OUTPUT
              echo "‚úÖ Loaded ports from project.yml: ${EXTERNAL_PORT}:${INTERNAL_PORT}"
            else
              echo "‚ùå ERROR: Parser script not found at: $PARSER_SCRIPT"
              exit 1
            fi
          else
            echo "‚ùå ERROR: Project file not found at: $CONFIG_FILE"
            exit 1
          fi
      
      - name: Generate docker-compose for service
        run: |
          set -e  # Exit on error
          
          # Create directory structure
          mkdir -p /opt/apps/${{ env.PROJECT }}/compose
          
          # Verify directory was created
          if [ ! -d "/opt/apps/${{ env.PROJECT }}/compose" ]; then
            echo "‚ùå Failed to create compose directory"
            exit 1
          fi
          
          # Use ports from project.yml
          EXTERNAL_PORT="${{ steps.config.outputs.external_port }}"
          INTERNAL_PORT="${{ steps.config.outputs.internal_port }}"
          
          echo "üîß Generating compose with ports: ${EXTERNAL_PORT}:${INTERNAL_PORT}"
          
          # Generate compose file from template
          cat > /opt/apps/${{ env.PROJECT }}/compose/docker-compose-${{ env.SERVICE }}.yml <<'EOF'
          version: '3.8'
          
          networks:
            PROJECT_NETWORK:
              external: true
            superdeploy-proxy:
              external: true
          
          services:
            SERVICE_NAME:
              image: IMAGE_PLACEHOLDER
              container_name: CONTAINER_NAME
              restart: unless-stopped
              networks:
                - PROJECT_NETWORK
                - superdeploy-proxy
              ports:
                - "{{EXTERNAL_PORT}}:{{INTERNAL_PORT}}"
              env_file:
                - /tmp/decrypted.env
              labels:
                com.superdeploy.project: "PROJECT_PLACEHOLDER"
                com.superdeploy.service: "SERVICE_PLACEHOLDER"
                com.superdeploy.git.sha: "GIT_SHA_PLACEHOLDER"
                com.superdeploy.git.ref: "GIT_REF_PLACEHOLDER"
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:{{INTERNAL_PORT}}/health"]
                interval: 15s
                timeout: 10s
                retries: 5
                start_period: 60s  # Longer grace period for slow starts
          EOF
          
          # Replace placeholders (using # as delimiter to avoid conflicts with URLs)
          COMPOSE_FILE="/opt/apps/${{ env.PROJECT }}/compose/docker-compose-${{ env.SERVICE }}.yml"
          
          sed -i "s#PROJECT_NETWORK#${{ env.PROJECT }}-network#g" "$COMPOSE_FILE"
          sed -i "s#SERVICE_NAME#${{ env.PROJECT }}-${{ env.SERVICE }}#g" "$COMPOSE_FILE"
          sed -i "s#CONTAINER_NAME#${{ env.PROJECT }}-${{ env.SERVICE }}#g" "$COMPOSE_FILE"
          sed -i "s#IMAGE_PLACEHOLDER#${{ env.IMAGE }}#g" "$COMPOSE_FILE"
          sed -i "s#PROJECT_PLACEHOLDER#${{ env.PROJECT }}#g" "$COMPOSE_FILE"
          sed -i "s#SERVICE_PLACEHOLDER#${{ env.SERVICE }}#g" "$COMPOSE_FILE"
          sed -i "s#GIT_SHA_PLACEHOLDER#${{ env.GIT_SHA }}#g" "$COMPOSE_FILE"
          sed -i "s#GIT_REF_PLACEHOLDER#${{ env.GIT_REF }}#g" "$COMPOSE_FILE"
          sed -i "s#{{EXTERNAL_PORT}}#${EXTERNAL_PORT}#g" "$COMPOSE_FILE"
          sed -i "s#{{INTERNAL_PORT}}#${INTERNAL_PORT}#g" "$COMPOSE_FILE"
          
          echo "‚úÖ Generated compose file with ports: ${EXTERNAL_PORT}:${INTERNAL_PORT}"
          echo "üìã Final compose file (ports section):"
          grep -A2 "ports:" "$COMPOSE_FILE"
      
      - name: Create networks first
        run: |
          set -e
          echo "üåê Creating networks..."
          
          # Create project network if it doesn't exist
          if ! docker network ls | grep -q "${{ env.PROJECT }}-network"; then
            docker network create ${{ env.PROJECT }}-network || echo "‚ö†Ô∏è  Network creation failed (may already exist)"
            echo "‚úÖ Network created: ${{ env.PROJECT }}-network"
          else
            echo "‚úÖ Network already exists: ${{ env.PROJECT }}-network"
          fi
          
          # Ensure superdeploy-proxy network exists (for Caddy)
          if ! docker network ls | grep -q "superdeploy-proxy"; then
            docker network create superdeploy-proxy || echo "‚ö†Ô∏è  Network creation failed (may already exist)"
            echo "‚úÖ Network created: superdeploy-proxy"
          else
            echo "‚úÖ Network already exists: superdeploy-proxy"
          fi
      
      - name: Copy compose files to VM
        run: |
          set -e
          echo "ÔøΩ Copiying compose files to VM..."
          
          # Ensure compose directory exists
          mkdir -p /opt/superdeploy/projects/${{ env.PROJECT }}/compose
          
          # Copy compose files from checkout to VM location
          if [ -f "projects/${{ env.PROJECT }}/compose/docker-compose.core.yml" ]; then
            cp projects/${{ env.PROJECT }}/compose/docker-compose.core.yml /opt/superdeploy/projects/${{ env.PROJECT }}/compose/
            echo "‚úÖ Copied docker-compose.core.yml"
          fi
          
          if [ -f "projects/${{ env.PROJECT }}/compose/docker-compose.apps.yml" ]; then
            cp projects/${{ env.PROJECT }}/compose/docker-compose.apps.yml /opt/superdeploy/projects/${{ env.PROJECT }}/compose/
            echo "‚úÖ Copied docker-compose.apps.yml"
          fi
      
      - name: Verify core services are running
        run: |
          set -e
          echo "üîç Verifying core services are running..."
          
          # Check if core services are running using docker ps
          echo "ÔøΩ Checkring core services status..."
          
          REQUIRED_SERVICES="${{ env.PROJECT }}-forgejo ${{ env.PROJECT }}-postgres ${{ env.PROJECT }}-rabbitmq"
          MISSING_SERVICES=""
          
          for service in $REQUIRED_SERVICES; do
            if ! docker ps --format '{{.Names}}' | grep -q "^${service}$"; then
              MISSING_SERVICES="$MISSING_SERVICES $service"
            fi
          done
          
          if [ -n "$MISSING_SERVICES" ]; then
            echo "‚ùå Core services not running:$MISSING_SERVICES"
            echo "   Run 'superdeploy up -p ${{ env.PROJECT }}' first to set up infrastructure"
            exit 1
          fi
          
          echo "‚úÖ All core services are running"
      
      - name: Register service with Caddy
        continue-on-error: true
        run: |
          set -e
          echo "üåê Registering ${{ env.SERVICE }} with Caddy reverse proxy..."
          
          # Get ports from project.yml
          EXTERNAL_PORT="${{ steps.config.outputs.external_port }}"
          INTERNAL_PORT="${{ steps.config.outputs.internal_port }}"
          
          # Create Caddy routes directory if not exists
          mkdir -p /opt/superdeploy/shared/caddy/routes
          
          # Check if Caddy is running
          if ! docker ps | grep -q superdeploy-caddy; then
            echo "‚ö†Ô∏è  Caddy not running, skipping route registration"
            echo "   Routes will be loaded when Caddy starts"
            exit 0
          fi
          
          # Generate Caddy route based on service type
          if [ "${{ env.SERVICE }}" == "dashboard" ]; then
            # Dashboard gets root domain (port 80)
            cat > /opt/superdeploy/shared/caddy/routes/${{ env.PROJECT }}-dashboard.caddy <<EOF
          # Auto-generated route for ${{ env.PROJECT }} dashboard
          # External: Port 80 (root domain)
          # Internal: Container port ${INTERNAL_PORT}
          :80 {
            reverse_proxy ${{ env.PROJECT }}-dashboard:${INTERNAL_PORT}
          }
          EOF
            echo "‚úÖ Dashboard registered: :80 ‚Üí ${{ env.PROJECT }}-dashboard:${INTERNAL_PORT}"
          else
            # Other services get their own port routes
            cat > /opt/superdeploy/shared/caddy/routes/${{ env.PROJECT }}-${{ env.SERVICE }}.caddy <<EOF
          # Auto-generated route for ${{ env.PROJECT }} ${{ env.SERVICE }}
          # External: Port ${EXTERNAL_PORT}
          # Internal: Container port ${INTERNAL_PORT}
          :${EXTERNAL_PORT} {
            reverse_proxy ${{ env.PROJECT }}-${{ env.SERVICE }}:${INTERNAL_PORT}
          }
          EOF
            echo "‚úÖ ${{ env.SERVICE }} registered: :${EXTERNAL_PORT} ‚Üí ${{ env.PROJECT }}-${{ env.SERVICE }}:${INTERNAL_PORT}"
          fi
          
          # Restart Caddy to pick up new routes (reload doesn't work with volume mounts)
          echo "üîÑ Restarting Caddy to load new routes..."
          docker restart superdeploy-caddy
          
          # Wait for Caddy to be ready
          sleep 3
          
          # Verify route is loaded
          docker exec superdeploy-caddy caddy list-modules --packages | grep -q http.handlers.reverse_proxy && echo "‚úÖ Caddy restarted successfully" || echo "‚ö†Ô∏è  Caddy may not be ready yet"
      
      - name: Backup current deployment
        id: backup
        run: |
          echo "üíæ Backing up current deployment..."
          
          # Get current image (for rollback)
          CURRENT_IMAGE=$(docker inspect ${{ env.PROJECT }}-${{ env.SERVICE }} --format '{{.Config.Image}}' 2>/dev/null || echo "none")
          echo "current_image=${CURRENT_IMAGE}" >> $GITHUB_OUTPUT
          echo "üì¶ Current image: ${CURRENT_IMAGE}"
      
      - name: Deploy service
        id: deploy
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üöÄ Deploying service: ${{ env.SERVICE }}"
          
          cd /opt/apps/${{ env.PROJECT }}/compose
          
          echo "üìÇ Current directory: $(pwd)"
          echo "üìã Compose file:"
          cat docker-compose-${{ env.SERVICE }}.yml
          
          # Pull latest image with retry
          echo "üì• Pulling image: ${{ env.IMAGE }}"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if docker pull ${{ env.IMAGE }}; then
              echo "‚úÖ Image pulled successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è  Pull failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
                sleep 5
              else
                echo "‚ùå Failed to pull image after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          # Deploy with zero-downtime using docker-compose
          echo "üê≥ Starting service container..."
          docker-compose -f docker-compose-${{ env.SERVICE }}.yml up -d --wait
          
          echo "üìä Container status:"
          docker ps -a --filter "name=${{ env.PROJECT }}-${{ env.SERVICE }}"
          
          # Wait for health check with better feedback
          echo "üè• Waiting for health check..."
          TIMEOUT=180  # 3 minutes timeout
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            STATUS=$(docker inspect --format="{{.State.Health.Status}}" ${{ env.PROJECT }}-${{ env.SERVICE }} 2>/dev/null || echo "unknown")
            
            if [ "$STATUS" = "healthy" ]; then
              echo "‚úÖ Service is healthy!"
              break
            fi
            
            echo "‚è≥ Health check status: $STATUS (${ELAPSED}s elapsed)"
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ùå Health check timeout after ${TIMEOUT}s!"
            echo "üìã Container logs (last 100 lines):"
            docker logs ${{ env.PROJECT }}-${{ env.SERVICE }} --tail 100
            echo "üìä Container inspect:"
            docker inspect ${{ env.PROJECT }}-${{ env.SERVICE }}
            exit 1
          fi
          
          echo "‚úÖ Service deployed and healthy!"
      
      - name: Rollback on failure
        if: failure() && steps.backup.outputs.current_image != 'none'
        run: |
          echo "‚ùå Deployment failed! Rolling back..."
          
          ROLLBACK_IMAGE="${{ steps.backup.outputs.current_image }}"
          
          if [ "$ROLLBACK_IMAGE" != "none" ]; then
            echo "üîÑ Rolling back to: $ROLLBACK_IMAGE"
            
            cd /opt/apps/${{ env.PROJECT }}/compose
            
            # Pull old image
            docker pull "$ROLLBACK_IMAGE" || echo "‚ö†Ô∏è  Could not pull rollback image"
            
            # Stop current container
            docker stop ${{ env.PROJECT }}-${{ env.SERVICE }} || true
            docker rm ${{ env.PROJECT }}-${{ env.SERVICE }} || true
            
            # Start with old image using docker run (bypass compose validation)
            docker run -d \
              --name ${{ env.PROJECT }}-${{ env.SERVICE }} \
              --network ${{ env.PROJECT }}-network \
              --network superdeploy-proxy \
              --env-file /tmp/decrypted.env \
              --restart unless-stopped \
              --label com.superdeploy.project="${{ env.PROJECT }}" \
              --label com.superdeploy.service="${{ env.SERVICE }}" \
              --label com.superdeploy.rollback="true" \
              "$ROLLBACK_IMAGE"
            
            echo "‚úÖ Rollback complete!"
            echo "üìß Sending rollback notification..."
          else
            echo "‚ö†Ô∏è  No previous deployment found, cannot rollback"
          fi
      
      - name: Cleanup old images
        continue-on-error: true
        run: |
          # Keep last 3 images
          docker images ghcr.io/*/${{ env.SERVICE }} --format "{{.ID}}" | tail -n +4 | xargs -r docker rmi || true
      
      - name: Clean up secrets
        if: always()
        run: |
          rm -f /tmp/decrypted.env
          rm -f /tmp/encrypted.age
      
      - name: Send notification
        if: always()
        continue-on-error: true
        run: |
          STATUS="${{ job.status }}"
          if [ "$STATUS" == "success" ]; then
            EMOJI="‚úÖ"
            COLOR="good"
          else
            EMOJI="‚ùå"
            COLOR="danger"
          fi
          
          # Send email notification (optional, may not be configured)
          if command -v mail &> /dev/null && [ -n "${{ secrets.ALERT_EMAIL }}" ]; then
            echo "Deployment $STATUS: ${{ env.PROJECT }}/${{ env.SERVICE }} @ ${{ env.GIT_SHA }}" | \
              mail -s "[$EMOJI] Deployment $STATUS" ${{ secrets.ALERT_EMAIL }} || true
          else
            echo "üìß Email notification skipped (mail not configured)"
          fi
