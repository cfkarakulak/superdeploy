name: Deploy Service

on:
  workflow_dispatch:
    inputs:
      project:
        description: 'Project name (e.g., cheapa, myapp)'
        required: true
        type: string
      service:
        description: 'Service name (e.g., api, dashboard, services)'
        required: true
        type: string
      image:
        description: 'Docker image with tag (e.g., ghcr.io/cheapaio/api:abc123)'
        required: true
        type: string
      env_bundle:
        description: 'AGE-encrypted environment variables bundle'
        required: true
        type: string
      git_sha:
        description: 'Git commit SHA (for tracking)'
        required: true
        type: string
      git_ref:
        description: 'Git ref (branch/tag)'
        required: false
        default: 'production'
        type: string

jobs:
  deploy:
    runs-on: [self-hosted, linux]
    
    env:
      PROJECT: ${{ inputs.project }}
      SERVICE: ${{ inputs.service }}
      IMAGE: ${{ inputs.image }}
      ENV_BUNDLE: ${{ inputs.env_bundle }}
      GIT_SHA: ${{ inputs.git_sha }}
      GIT_REF: ${{ inputs.git_ref }}
    
    steps:
      - name: Checkout superdeploy repo
        uses: actions/checkout@v4
      
      - name: Decrypt environment bundle
        id: decrypt
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üîê Decrypting environment bundle..."
          echo "${{ env.ENV_BUNDLE }}" | base64 -d > /tmp/encrypted.age
          echo "‚úÖ Base64 decoded successfully"
          
          age -d -i /opt/forgejo-runner/.age/key.txt /tmp/encrypted.age > /tmp/decrypted.env
          echo "‚úÖ AGE decryption successful"
          
          echo "üìã Decrypted env file contents (first 5 lines, masked):"
          head -5 /tmp/decrypted.env | sed 's/=.*/=***MASKED***/g'
          
          rm /tmp/encrypted.age
          echo "env_file=/tmp/decrypted.env" >> $GITHUB_OUTPUT
          echo "‚úÖ Decrypt step completed"
      
      - name: Load environment variables
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üì• Loading environment variables..."
          
          set -a
          source /tmp/decrypted.env
          set +a
          
          echo "‚úÖ Environment sourced successfully"
          
          # Save to GitHub env for next steps (filter out comments and empty lines)
          grep -v '^#' /tmp/decrypted.env | grep -v '^$' >> $GITHUB_ENV
          
          echo "üìä Total env vars loaded: $(grep -v '^#' /tmp/decrypted.env | grep -v '^$' | wc -l)"
          echo "‚úÖ Load env step completed"
      
      - name: Login to Docker Hub
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üê≥ Logging in to Docker Hub..."
          
          # Login using Docker Hub credentials from Forgejo secrets
          echo "${{ secrets.DOCKER_TOKEN }}" | docker login docker.io -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          
          echo "‚úÖ Docker Hub login successful"
      
      - name: Load project configuration
        id: config
        run: |
          set -ex
          echo "üìã Loading project configuration..."
          
          # Read port configuration from project config.yml
          CONFIG_FILE="/opt/superdeploy/projects/${{ env.PROJECT }}/config.yml"
          
          if [ -f "$CONFIG_FILE" ]; then
            # Use helper script to parse YAML config
            PARSER_SCRIPT="${GITHUB_WORKSPACE}/.forgejo/scripts/parse_config.py"
            
            if [ -f "$PARSER_SCRIPT" ]; then
              read EXTERNAL_PORT INTERNAL_PORT <<< $(python3 "$PARSER_SCRIPT" "$CONFIG_FILE" "${{ env.SERVICE }}")
              echo "external_port=${EXTERNAL_PORT}" >> $GITHUB_OUTPUT
              echo "internal_port=${INTERNAL_PORT}" >> $GITHUB_OUTPUT
              echo "‚úÖ Loaded ports from config: ${EXTERNAL_PORT}:${INTERNAL_PORT}"
            else
              echo "‚ö†Ô∏è  Parser script not found, using defaults"
              echo "external_port=8080" >> $GITHUB_OUTPUT
              echo "internal_port=8080" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è  Config file not found, using defaults"
            echo "external_port=8080" >> $GITHUB_OUTPUT
            echo "internal_port=8080" >> $GITHUB_OUTPUT
          fi
      
      - name: Generate docker-compose for service
        run: |
          mkdir -p /opt/apps/${{ env.PROJECT }}/compose
          
          # Use ports from config
          EXTERNAL_PORT="${{ steps.config.outputs.external_port }}"
          INTERNAL_PORT="${{ steps.config.outputs.internal_port }}"
          
          echo "üîß Generating compose with ports: ${EXTERNAL_PORT}:${INTERNAL_PORT}"
          
          # Generate compose file from template
          cat > /opt/apps/${{ env.PROJECT }}/compose/docker-compose-${{ env.SERVICE }}.yml <<'EOF'
          version: '3.8'
          
          networks:
            PROJECT_NETWORK:
              external: true
            superdeploy-proxy:
              external: true
          
          services:
            SERVICE_NAME:
              image: IMAGE_PLACEHOLDER
              container_name: CONTAINER_NAME
              restart: unless-stopped
              networks:
                - PROJECT_NETWORK
                - superdeploy-proxy
              ports:
                - "{{EXTERNAL_PORT}}:{{INTERNAL_PORT}}"
              env_file:
                - /tmp/decrypted.env
              labels:
                com.superdeploy.project: "PROJECT_PLACEHOLDER"
                com.superdeploy.service: "SERVICE_PLACEHOLDER"
                com.superdeploy.git.sha: "GIT_SHA_PLACEHOLDER"
                com.superdeploy.git.ref: "GIT_REF_PLACEHOLDER"
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:{{INTERNAL_PORT}}/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          EOF
          
          # Replace placeholders (using # as delimiter to avoid conflicts with URLs)
          COMPOSE_FILE="/opt/apps/${{ env.PROJECT }}/compose/docker-compose-${{ env.SERVICE }}.yml"
          
          sed -i "s#PROJECT_NETWORK#${{ env.PROJECT }}-network#g" "$COMPOSE_FILE"
          sed -i "s#SERVICE_NAME#${{ env.PROJECT }}-${{ env.SERVICE }}#g" "$COMPOSE_FILE"
          sed -i "s#CONTAINER_NAME#${{ env.PROJECT }}-${{ env.SERVICE }}#g" "$COMPOSE_FILE"
          sed -i "s#IMAGE_PLACEHOLDER#${{ env.IMAGE }}#g" "$COMPOSE_FILE"
          sed -i "s#PROJECT_PLACEHOLDER#${{ env.PROJECT }}#g" "$COMPOSE_FILE"
          sed -i "s#SERVICE_PLACEHOLDER#${{ env.SERVICE }}#g" "$COMPOSE_FILE"
          sed -i "s#GIT_SHA_PLACEHOLDER#${{ env.GIT_SHA }}#g" "$COMPOSE_FILE"
          sed -i "s#GIT_REF_PLACEHOLDER#${{ env.GIT_REF }}#g" "$COMPOSE_FILE"
          sed -i "s#{{EXTERNAL_PORT}}#${EXTERNAL_PORT}#g" "$COMPOSE_FILE"
          sed -i "s#{{INTERNAL_PORT}}#${INTERNAL_PORT}#g" "$COMPOSE_FILE"
          
          echo "‚úÖ Generated compose file with ports: ${EXTERNAL_PORT}:${INTERNAL_PORT}"
          echo "üìã Final compose file (ports section):"
          grep -A2 "ports:" "$COMPOSE_FILE"
      
      - name: Deploy core services first
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üîß Checking for core services..."
          
          # Deploy core services (PostgreSQL, RabbitMQ, Redis) if not running
          CORE_COMPOSE="/opt/superdeploy/projects/${{ env.PROJECT }}/compose/docker-compose.core.yml"
          
          if [ -f "$CORE_COMPOSE" ]; then
            echo "üì¶ Deploying core services (PostgreSQL, RabbitMQ, Redis)..."
            cd /opt/superdeploy/projects/${{ env.PROJECT }}/compose
            
            echo "üìÇ Current directory: $(pwd)"
            echo "üìã Files in directory:"
            ls -la
            
            # Load environment variables from decrypted file (skip comments and empty lines)
            export $(grep -v '^#' /tmp/decrypted.env | grep -v '^$' | xargs)
            
            echo "üê≥ Starting core services..."
            # Deploy core services
            docker compose -f docker-compose.core.yml up -d --wait
            
            echo "üìä Core services status:"
            docker compose -f docker-compose.core.yml ps
            
            echo "‚úÖ Core services deployed!"
          else
            echo "‚ö†Ô∏è  No core services compose file found at: $CORE_COMPOSE"
            echo "üìÇ Listing /opt/superdeploy/projects/${{ env.PROJECT }}:"
            ls -la /opt/superdeploy/projects/${{ env.PROJECT }}/ || echo "Directory not found"
          fi
      
      - name: Register service with Caddy
        run: |
          set -ex
          echo "üåê Registering ${{ env.SERVICE }} with Caddy reverse proxy..."
          
          # Get ports from config
          EXTERNAL_PORT="${{ steps.config.outputs.external_port }}"
          INTERNAL_PORT="${{ steps.config.outputs.internal_port }}"
          
          # Create Caddy routes directory if not exists
          mkdir -p /opt/superdeploy/shared/caddy/routes
          
          # Generate Caddy route based on service type
          if [ "${{ env.SERVICE }}" == "dashboard" ]; then
            # Dashboard gets root domain (port 80)
            cat > /opt/superdeploy/shared/caddy/routes/${{ env.PROJECT }}-dashboard.caddy <<EOF
          # Auto-generated route for ${{ env.PROJECT }} dashboard
          # External: Port 80 (root domain)
          # Internal: Container port ${INTERNAL_PORT}
          :80 {
            reverse_proxy ${{ env.PROJECT }}-dashboard:${INTERNAL_PORT}
          }
          EOF
            echo "‚úÖ Dashboard registered: :80 ‚Üí ${{ env.PROJECT }}-dashboard:${INTERNAL_PORT}"
          else
            # Other services get their own port routes
            cat > /opt/superdeploy/shared/caddy/routes/${{ env.PROJECT }}-${{ env.SERVICE }}.caddy <<EOF
          # Auto-generated route for ${{ env.PROJECT }} ${{ env.SERVICE }}
          # External: Port ${EXTERNAL_PORT}
          # Internal: Container port ${INTERNAL_PORT}
          :${EXTERNAL_PORT} {
            reverse_proxy ${{ env.PROJECT }}-${{ env.SERVICE }}:${INTERNAL_PORT}
          }
          EOF
            echo "‚úÖ ${{ env.SERVICE }} registered: :${EXTERNAL_PORT} ‚Üí ${{ env.PROJECT }}-${{ env.SERVICE }}:${INTERNAL_PORT}"
          fi
          
          # Reload Caddy to pick up new routes
          docker exec superdeploy-caddy caddy reload --config /etc/caddy/Caddyfile || echo "‚ö†Ô∏è  Caddy reload failed (may not be running yet)"
      
      - name: Deploy service
        run: |
          set -ex  # Enable verbose mode and exit on error
          echo "üöÄ Deploying service: ${{ env.SERVICE }}"
          
          cd /opt/apps/${{ env.PROJECT }}/compose
          
          echo "üìÇ Current directory: $(pwd)"
          echo "üìã Compose file:"
          cat docker-compose-${{ env.SERVICE }}.yml
          
          # Create project network if it doesn't exist
          echo "üåê Creating/checking network: ${{ env.PROJECT }}-network"
          docker network create ${{ env.PROJECT }}-network 2>/dev/null || echo "Network already exists"
          
          # Pull latest image
          echo "üì• Pulling image: ${{ env.IMAGE }}"
          docker pull ${{ env.IMAGE }}
          
          # Deploy with zero-downtime
          echo "üê≥ Starting service container..."
          docker compose -f docker-compose-${{ env.SERVICE }}.yml up -d --wait
          
          echo "üìä Container status:"
          docker ps -a --filter "name=${{ env.PROJECT }}-${{ env.SERVICE }}"
          
          # Wait for health check
          echo "üè• Waiting for health check..."
          timeout 120 bash -c 'until docker inspect --format="{{.State.Health.Status}}" ${{ env.PROJECT }}-${{ env.SERVICE }} | grep -q "healthy"; do echo "Waiting for health check... ($(docker inspect --format="{{.State.Health.Status}}" ${{ env.PROJECT }}-${{ env.SERVICE }}))"; sleep 2; done' || {
            echo "‚ùå Health check failed!"
            echo "üìã Container logs (last 100 lines):"
            docker logs ${{ env.PROJECT }}-${{ env.SERVICE }} --tail 100
            echo "üìä Container inspect:"
            docker inspect ${{ env.PROJECT }}-${{ env.SERVICE }}
            exit 1
          }
          
          echo "‚úÖ Service deployed and healthy!"
      
      - name: Cleanup old images
        run: |
          # Keep last 3 images
          docker images ghcr.io/*/${{ env.SERVICE }} --format "{{.ID}}" | tail -n +4 | xargs -r docker rmi || true
      
      - name: Clean up secrets
        if: always()
        run: |
          rm -f /tmp/decrypted.env
          rm -f /tmp/encrypted.age
      
      - name: Send notification
        if: always()
        run: |
          STATUS="${{ job.status }}"
          if [ "$STATUS" == "success" ]; then
            EMOJI="‚úÖ"
            COLOR="good"
          else
            EMOJI="‚ùå"
            COLOR="danger"
          fi
          
          # Send email notification
          echo "Deployment $STATUS: ${{ env.PROJECT }}/${{ env.SERVICE }} @ ${{ env.GIT_SHA }}" | \
            mail -s "[$EMOJI] Deployment $STATUS" $ALERT_EMAIL || true
