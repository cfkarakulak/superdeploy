name: Deploy Application

on:
  workflow_dispatch:
    inputs:
      title:
        description: 'Workflow title (auto-generated from GitHub)'
        required: false
        default: 'Deploy Application'
      project:
        description: 'Project name (cheapa, projectb, etc.)'
        required: true
        default: 'cheapa'
      environment:
        description: 'Environment (prod|staging)'
        required: true
        default: 'prod'
        type: choice
        options:
          - prod
          - staging
      services:
        description: 'Services to deploy (comma-separated: api,dashboard,services)'
        required: true
        default: 'api'
      image_tags:
        description: 'JSON: {"api":"abc123","dashboard":"def456","services":"ghi789"}'
        required: true
      encrypted_env:
        description: 'Encrypted environment variables (base64 of AGE-encrypted .env)'
        required: false
        default: ''
      migrate:
        description: 'Run DB migrations (true/false)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

jobs:
  deploy:
    runs-on: [self-hosted, core, linux, docker]  # Generic runner labels
    
    env:
      PROJECT: ${{ github.event.inputs.project }}
      ENVIRONMENT: ${{ github.event.inputs.environment }}
      SERVICES: ${{ github.event.inputs.services }}
      IMAGE_TAGS: ${{ github.event.inputs.image_tags }}
      MIGRATE: ${{ github.event.inputs.migrate }}
    
    steps:
      - name: ${{ github.event.inputs.title || 'Deploy Application' }}
        run: |
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "  ${{ github.event.inputs.title || 'Deploy Application' }}"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo ""
          echo "üìã Deployment Info:"
          echo "  Project: ${{ github.event.inputs.project }}"
          echo "  Environment: ${{ github.event.inputs.environment }}"
          echo "  Services: ${{ github.event.inputs.services }}"
          echo ""

      - name: Checkout superdeploy code
        run: |
          cd /opt/superdeploy
          git config --global --add safe.directory /opt/superdeploy
          git fetch origin
          git reset --hard origin/master
          echo "‚úÖ Superdeploy code updated"

      - name: Decrypt environment variables
        id: decrypt
        run: |
          set +x  # Disable echo for security
          
          ENCRYPTED_ENV="${{ github.event.inputs.encrypted_env }}"
          
          if [ -n "$ENCRYPTED_ENV" ] && [ "$ENCRYPTED_ENV" != "" ]; then
            echo "üîê Decrypting environment variables..."
            
            # Decode base64 and decrypt with AGE private key
            echo "$ENCRYPTED_ENV" | base64 -d | age -d -i /opt/forgejo-runner/.age/key.txt > /opt/superdeploy/.env.decrypted 2>/dev/null
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Environment decrypted successfully"
              echo "env_file=/opt/superdeploy/.env.decrypted" >> $GITHUB_OUTPUT
            else
              echo "‚ùå Failed to decrypt environment"
              echo "env_file=" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è  No encrypted environment provided, using Forgejo secrets fallback"
            echo "env_file=" >> $GITHUB_OUTPUT
          fi

      - name: Parse inputs
        id: parse
        run: |
          # Parse JSON image_tags
          echo "$IMAGE_TAGS" > /tmp/image_tags.json
          
          # Extract tags for each service
          API_TAG=$(jq -r '.api // "latest"' /tmp/image_tags.json)
          DASHBOARD_TAG=$(jq -r '.dashboard // "latest"' /tmp/image_tags.json)
          SERVICES_TAG=$(jq -r '.services // "latest"' /tmp/image_tags.json)
          
          echo "api_tag=$API_TAG" >> $GITHUB_OUTPUT
          echo "dashboard_tag=$DASHBOARD_TAG" >> $GITHUB_OUTPUT
          echo "services_tag=$SERVICES_TAG" >> $GITHUB_OUTPUT
          
          echo "üìã Parsed tags:"
          echo "  API: $API_TAG"
          echo "  Dashboard: $DASHBOARD_TAG"
          echo "  Services: $SERVICES_TAG"

      - name: Save decrypted environment to project directory
        if: steps.decrypt.outputs.env_file != ''
        run: |
          PROJECT="${{ github.event.inputs.project }}"
          ENV_FILE="${{ steps.decrypt.outputs.env_file }}"
          PROJECT_DIR="/opt/apps/${PROJECT}"
          
          # Ensure project directory exists
          if [ ! -d "$PROJECT_DIR" ]; then
            echo "‚ùå Project '${PROJECT}' not initialized!"
            echo "Run: superdeploy init -p ${PROJECT}"
            exit 1
          fi
          
          # Copy decrypted env to project directory
          cp "$ENV_FILE" "${PROJECT_DIR}/compose/.env"
          
          # Set proper permissions
          chmod 600 "${PROJECT_DIR}/compose/.env"
          chown superdeploy:superdeploy "${PROJECT_DIR}/compose/.env"
          
          echo "‚úÖ Environment saved to ${PROJECT_DIR}/compose/.env"

      - name: Verify project setup
        run: |
          PROJECT="${{ github.event.inputs.project }}"
          PROJECT_DIR="/opt/apps/${PROJECT}"
          
          if [ ! -d "$PROJECT_DIR" ]; then
            echo "‚ùå Project '${PROJECT}' not found!"
            echo "Please initialize project first: superdeploy init -p ${PROJECT}"
            exit 1
          fi
          
          # Check for compose files
          if [ ! -f "${PROJECT_DIR}/compose/docker-compose.core.yml" ]; then
            echo "‚ùå Missing docker-compose.core.yml"
            exit 1
          fi
          
          if [ ! -f "${PROJECT_DIR}/compose/docker-compose.apps.yml" ]; then
            echo "‚ùå Missing docker-compose.apps.yml"
            exit 1
          fi
          
          cd "${PROJECT_DIR}/compose"
          echo "‚úÖ Project '${PROJECT}' is properly configured"

      - name: Pull images (selective)
        run: |
          PROJECT="${{ github.event.inputs.project }}"
          cd /opt/apps/${PROJECT}/compose
          
          # Load infrastructure env
          set -a
          source /opt/superdeploy/.env
          set +a
          
          # Set image tags
          export API_IMAGE_TAG="${{ steps.parse.outputs.api_tag }}"
          export DASHBOARD_IMAGE_TAG="${{ steps.parse.outputs.dashboard_tag }}"
          export SERVICES_IMAGE_TAG="${{ steps.parse.outputs.services_tag }}"
          
          # Ensure DOCKER_REGISTRY is set
          export DOCKER_REGISTRY="${DOCKER_REGISTRY:-docker.io}"
          
          # GitHub must provide encrypted env (no fallback)
          ENV_FILE="${{ steps.decrypt.outputs.env_file }}"
          
          if [ -n "$ENV_FILE" ] && [ -f "$ENV_FILE" ]; then
            echo "üì• Loading decrypted environment from GitHub"
            set -a
            source "$ENV_FILE"
            set +a
          else
            echo "‚ùå No environment provided from GitHub!"
            echo "Cannot proceed without credentials"
            exit 1
          fi
          
          # Deployment timestamp
          export DEPLOY_TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          
          # Parse services to deploy
          IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
          
          echo "üì• Pulling images for: ${SERVICE_ARRAY[@]}"
          
          # Pull only specified services
          for service in "${SERVICE_ARRAY[@]}"; do
            service=$(echo $service | xargs)  # trim whitespace
            echo "Pulling $service..."
            docker compose pull $service || echo "‚ö†Ô∏è  Failed to pull $service"
          done
          
          echo "‚úÖ Images pulled!"

      - name: Run DB migrations (optional)
        if: ${{ github.event.inputs.migrate == 'true' }}
        timeout-minutes: 10
        run: |
          PROJECT="${{ github.event.inputs.project }}"
          cd /opt/apps/${PROJECT}/compose
          
          echo "üîÑ Running database migrations..."
          echo "‚ö†Ô∏è  Migration failure will STOP deployment"
          
          # Load env for compose
          set -a
          source /opt/superdeploy/.env
          set +a
          
          # Load env from GitHub
          ENV_FILE="${{ steps.decrypt.outputs.env_file }}"
          if [ -f "$ENV_FILE" ]; then
            set -a
            source "$ENV_FILE"
            set +a
          fi
          
          # Run migrations with timeout and error handling
          if docker compose -f docker-compose.core.yml -f docker-compose.apps.yml \
             run --rm api alembic upgrade head; then
            echo "‚úÖ Migrations completed successfully"
          else
            echo "‚ùå MIGRATION FAILED!"
            echo "‚ö†Ô∏è  Deployment will be aborted"
            echo "üìã Manual rollback may be required"
            exit 1
          fi
          
          # Verify migration was successful
          echo "üîç Verifying migration..."
          docker compose -f docker-compose.core.yml -f docker-compose.apps.yml \
            run --rm api alembic current || {
            echo "‚ùå Migration verification failed"
            exit 1
          }
          
          echo "‚úÖ Migration verified"

      - name: Deploy core services (always)
        run: |
          PROJECT="${{ github.event.inputs.project }}"
          cd /opt/apps/${PROJECT}/compose
          
          echo "üîß Deploying core services (postgres, rabbitmq, redis)..."
          
          # Load decrypted env from GitHub (MUST have project-specific creds)
          ENV_FILE="${{ steps.decrypt.outputs.env_file }}"
          
          if [ -z "$ENV_FILE" ] || [ ! -f "$ENV_FILE" ]; then
            echo "‚ùå No environment file provided from GitHub!"
            echo "Core services need project-specific credentials"
            exit 1
          fi
          
          # Load ALL credentials from GitHub
          set -a
          source "$ENV_FILE"
          set +a
          
          # Verify required vars
          if [ -z "$POSTGRES_PASSWORD" ] || [ -z "$RABBITMQ_PASSWORD" ] || [ -z "$REDIS_PASSWORD" ]; then
            echo "‚ùå Missing required credentials in environment file"
            exit 1
          fi
          
          # Deploy core services (always)
          docker compose -f docker-compose.core.yml up -d
          
          echo "‚úÖ Core services deployed!"
      
      - name: Deploy app services (selective)
        run: |
          PROJECT="${{ github.event.inputs.project }}"
          cd /opt/apps/${PROJECT}/compose
          
          # Load decrypted env from GitHub (contains ALL app+infra vars)
          ENV_FILE="${{ steps.decrypt.outputs.env_file }}"
          
          if [ -z "$ENV_FILE" ] || [ ! -f "$ENV_FILE" ]; then
            echo "‚ùå No environment file provided from GitHub!"
            exit 1
          fi
          
          # Load ALL vars from GitHub
          set -a
          source "$ENV_FILE"
          source /opt/superdeploy/.env  # For infra vars (IPs, etc)
          set +a
          
          # Set image tags from parsed inputs
          export API_IMAGE_TAG="${{ steps.parse.outputs.api_tag }}"
          export DASHBOARD_IMAGE_TAG="${{ steps.parse.outputs.dashboard_tag }}"
          export SERVICES_IMAGE_TAG="${{ steps.parse.outputs.services_tag }}"
          
          # Add deployment metadata
          export DEPLOY_TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          export GIT_SHA="${{ github.sha }}"
          export RELEASE_VERSION="v$(date +%Y%m%d)-${GITHUB_RUN_NUMBER:-1}"
          
          # Parse services
          IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
          
          echo "Deploying ${PROJECT} apps: ${SERVICE_ARRAY[@]}"
          
          # Deploy app services only
          docker compose -f docker-compose.apps.yml up -d --no-deps "${SERVICE_ARRAY[@]}"
          
          echo "‚úÖ App services deployed!"

      - name: ‚è≥ Wait for services to be healthy
        run: |
          PROJECT="${{ github.event.inputs.project }}"
          cd /opt/apps/${PROJECT}/compose
          
          echo "Waiting for services to be healthy..."
          sleep 10
          
          docker compose -f docker-compose.apps.yml ps
          echo "‚úÖ Services should be healthy!"

      - name: Health checks
        run: |
          PROJECT="${{ github.event.inputs.project }}"
          echo "Running health checks for project: ${PROJECT}..."
          
          # PostgreSQL
          docker exec ${PROJECT}-postgres pg_isready && \
            echo "‚úÖ PostgreSQL healthy" || echo "‚ùå PostgreSQL unhealthy"
          
          # RabbitMQ (if exists)
          if docker ps --format '{{.Names}}' | grep -q "^${PROJECT}-rabbitmq$"; then
            docker exec ${PROJECT}-rabbitmq rabbitmq-diagnostics ping && \
              echo "‚úÖ RabbitMQ healthy" || echo "‚ùå RabbitMQ unhealthy"
          fi
          
          # Redis (if exists)
          if docker ps --format '{{.Names}}' | grep -q "^${PROJECT}-redis$"; then
            docker exec ${PROJECT}-redis redis-cli ping && \
              echo "‚úÖ Redis healthy" || echo "‚ùå Redis unhealthy"
          fi
          
          # API health endpoint (if exists)
          if docker ps --format '{{.Names}}' | grep -q "^${PROJECT}-api$"; then
            curl -f http://localhost:8000/health 2>/dev/null && \
              echo "‚úÖ API healthy" || echo "‚ö†Ô∏è  API health check skipped (no endpoint)"
          fi

      - name: Show deployment status
        run: |
          PROJECT="${{ github.event.inputs.project }}"
          cd /opt/apps/${PROJECT}/compose
          
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "         üéâ DEPLOYMENT COMPLETE! üéâ                    "
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo ""
          echo "Project: ${PROJECT}"
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "Services: ${{ env.SERVICES }}"
          echo ""
          docker compose -f docker-compose.apps.yml ps
          echo ""
          echo "üåê Services are available at: http://$(curl -s ifconfig.me)"

      - name: Send deployment notification
        if: always()
        run: |
          set -x  # Enable debug output
          
          # Determine deployment status
          if [ "${{ job.status }}" = "success" ]; then
            STATUS="‚úÖ SUCCESS"
          else
            STATUS="‚ùå FAILED"
          fi
          
          # Get deployed image tags
          API_TAG="${{ steps.parse.outputs.api_tag }}"
          DASHBOARD_TAG="${{ steps.parse.outputs.dashboard_tag }}"
          SERVICES_TAG="${{ steps.parse.outputs.services_tag }}"
          
          # Get external IP
          EXTERNAL_IP=$(curl -s ifconfig.me 2>/dev/null || echo "unknown")
          
          # Email config (from Forgejo Secrets)
          ENV_NAME="${{ env.ENVIRONMENT }}"
          SERVICES_LIST="${{ env.SERVICES }}"
          ALERT_EMAIL="${{ secrets.ALERT_EMAIL }}"
          FORGEJO_ORG="${{ secrets.FORGEJO_ORG }}"
          WORKFLOW_TITLE="${{ github.event.inputs.title }}"
          SUBJECT="[${STATUS}] ${WORKFLOW_TITLE}"
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          # Debug: Print email config
          echo "DEBUG: Email Configuration"
          echo "  ALERT_EMAIL=${ALERT_EMAIL}"
          echo "  SUBJECT=${SUBJECT}"
          echo "  STATUS=${STATUS}"
          
          # Install mailutils if not present
          if ! command -v mail &> /dev/null; then
            echo "Installing mailutils..."
            export DEBIAN_FRONTEND=noninteractive
            apt-get update -qq && apt-get install -y mailutils postfix 2>&1 | grep -v "^Get:" || {
              echo "‚ö†Ô∏è  Failed to install mailutils - email will be skipped"
              echo "‚úÖ Deployment notification: ${STATUS} (email disabled)"
              exit 0
            }
          fi
          
          # Send email
          {
            echo "SuperDeploy Deployment Notification"
            echo ""
            echo "Status = ${STATUS}"
            echo "Environment = ${ENV_NAME}"
            echo "Services = ${SERVICES_LIST}"
            echo "Timestamp = ${TIMESTAMP}"
            echo ""
            echo "Deployed Images ="
            echo "  API = ${API_TAG}"
            echo "  Dashboard = ${DASHBOARD_TAG}"
            echo "  Services = ${SERVICES_TAG}"
            echo ""
            echo "Access URLs ="
            echo "  Dashboard = http://${EXTERNAL_IP}"
            echo "  API = http://${EXTERNAL_IP}:8000"
            echo "  Forgejo = http://${EXTERNAL_IP}:3001"
            echo ""
            echo "Logs = http://${EXTERNAL_IP}:3001/${FORGEJO_ORG}/superdeploy-app/actions"
          } | mail -s "$SUBJECT" "$ALERT_EMAIL" 2>&1 && {
            echo "‚úÖ Email sent to $ALERT_EMAIL"
          } || {
            echo "‚ö†Ô∏è  Email send failed (not critical)"
          }
          
          echo "‚úÖ Notification complete"

      - name: üßπ Cleanup decrypted env (security)
        if: always()
        run: |
          ENV_FILE="${{ steps.decrypt.outputs.env_file }}"
          if [ -n "$ENV_FILE" ] && [ -f "$ENV_FILE" ]; then
            echo "üîí Securely deleting decrypted env file..."
            shred -u "$ENV_FILE" 2>/dev/null || rm -f "$ENV_FILE"
            echo "‚úÖ Decrypted env removed"
          fi

