name: 'Deploy to VM'
description: 'Deploy a service to VM using Docker Compose'
author: 'Superdeploy Team'

inputs:
  project:
    description: 'Project name (e.g., cheapa)'
    required: true
  service:
    description: 'Service name (e.g., api, dashboard, services)'
    required: true
  image:
    description: 'Docker image with tag'
    required: true
  env_bundle:
    description: 'AGE-encrypted environment variables bundle (base64)'
    required: true
  git_sha:
    description: 'Git commit SHA'
    required: true
  git_ref:
    description: 'Git ref (branch/tag)'
    required: true
    default: 'production'

runs:
  using: 'composite'
  steps:
    - name: Setup age tool
      shell: bash
      run: |
        set -e
        echo "ğŸ“¦ Installing dependencies..."
        sudo apt-get update -qq
        sudo apt-get install -y -qq curl tar
        
        if ! command -v age &> /dev/null; then
          echo "ğŸ“¦ Installing age..."
          cd /tmp
          curl -sL https://github.com/FiloSottile/age/releases/download/v1.1.1/age-v1.1.1-linux-amd64.tar.gz -o age.tar.gz
          tar xzf age.tar.gz
          sudo cp age/age /usr/local/bin/
          sudo cp age/age-keygen /usr/local/bin/
          sudo chmod +x /usr/local/bin/age /usr/local/bin/age-keygen
          rm -rf age age.tar.gz
          echo "âœ… age installed"
        else
          echo "âœ… age already installed"
        fi
        age --version
    
    - name: Decrypt environment bundle
      shell: bash
      run: |
        set -ex
        echo "ğŸ” Decrypting environment bundle..."
        echo "${{ inputs.env_bundle }}" | base64 -d > /tmp/encrypted.age
        echo "âœ… Base64 decoded successfully"
        
        # Debug: Check encrypted file
        echo "ğŸ“Š Encrypted file size: $(wc -c < /tmp/encrypted.age) bytes"
        echo "ğŸ“Š First few bytes: $(head -c 50 /tmp/encrypted.age)"
        
        # Debug: Check AGE_SECRET_KEY
        if [ -z "$AGE_SECRET_KEY" ]; then
          echo "âŒ AGE_SECRET_KEY is empty or not set!"
          exit 1
        fi
        echo "âœ… AGE_SECRET_KEY is set (length: ${#AGE_SECRET_KEY})"
        
        # Write AGE key to file (more reliable than echo)
        printf '%s' "$AGE_SECRET_KEY" > /tmp/age-key.txt
        chmod 600 /tmp/age-key.txt
        
        # Debug: Check key file
        echo "ğŸ“Š Key file size: $(wc -c < /tmp/age-key.txt) bytes"
        echo "ğŸ“Š Key file first line: $(head -1 /tmp/age-key.txt)"
        
        # Decrypt with explicit error handling and verbose output
        echo "ğŸ”“ Running age decryption..."
        if ! age -d -i /tmp/age-key.txt /tmp/encrypted.age > /tmp/decrypted.env 2>&1; then
          echo "âŒ AGE decryption failed!"
          echo "ğŸ“‹ Decryption error output:"
          cat /tmp/decrypted.env
          rm -f /tmp/age-key.txt /tmp/encrypted.age /tmp/decrypted.env
          exit 1
        fi
        
        rm /tmp/age-key.txt
        
        # Verify decryption success
        if [ ! -s /tmp/decrypted.env ]; then
          echo "âŒ Decrypted file is empty!"
          cat /tmp/decrypted.env
          exit 1
        fi
        
        echo "âœ… AGE decryption successful"
        
        echo "ğŸ“‹ Decrypted env file contents (first 5 lines, masked):"
        head -5 /tmp/decrypted.env | sed 's/=.*/=***MASKED***/g'
        
        rm /tmp/encrypted.age
        echo "âœ… Decrypt step completed"
    
    - name: Load environment variables
      shell: bash
      run: |
        set -ex
        echo "ğŸ“¥ Loading environment variables..."
        
        if [ ! -f /tmp/decrypted.env ] || [ ! -s /tmp/decrypted.env ]; then
          echo "âŒ Decrypted env file not found or empty!"
          exit 1
        fi
        
        set -a
        source /tmp/decrypted.env
        set +a
        
        echo "âœ… Environment sourced successfully"
        
        # Save to GitHub env for next steps
        grep -v '^#' /tmp/decrypted.env | grep -v '^$' >> $GITHUB_ENV
        
        echo "ğŸ“Š Total env vars loaded: $(grep -v '^#' /tmp/decrypted.env | grep -v '^$' | wc -l)"
        echo "âœ… Load env step completed"
    
    - name: Login to Docker Hub
      shell: bash
      run: |
        set -ex
        echo "ğŸ³ Logging in to Docker Hub..."
        
        if [ -z "$DOCKER_USERNAME" ] || [ -z "$DOCKER_TOKEN" ]; then
          echo "âŒ Docker Hub credentials not found!"
          exit 1
        fi
        
        echo "$DOCKER_TOKEN" | docker login docker.io -u "$DOCKER_USERNAME" --password-stdin
        
        if [ $? -eq 0 ]; then
          echo "âœ… Docker Hub login successful"
        else
          echo "âŒ Docker Hub login failed!"
          exit 1
        fi
    
    - name: Load project configuration
      shell: bash
      run: |
        set -ex
        echo "ğŸ“‹ Loading project configuration..."
        
        CONFIG_FILE="/tmp/project.yml"
        
        # Use project.yml from checked out repo (workspace)
        if [ -f "${GITHUB_WORKSPACE}/projects/${{ inputs.project }}/project.yml" ]; then
          cp "${GITHUB_WORKSPACE}/projects/${{ inputs.project }}/project.yml" "$CONFIG_FILE"
          echo "âœ… Successfully loaded project.yml from workspace"
        else
          echo "âŒ ERROR: project.yml not found in workspace"
          echo "Tried: ${GITHUB_WORKSPACE}/projects/${{ inputs.project }}/project.yml"
          exit 1
        fi
        
        if [ -f "$CONFIG_FILE" ]; then
          PARSER_SCRIPT="${GITHUB_WORKSPACE}/.forgejo/scripts/parse_config.py"
          
          if [ -f "$PARSER_SCRIPT" ]; then
            echo "âœ… Parser script found"
            CONFIG_OUTPUT=$(python3 "$PARSER_SCRIPT" "$CONFIG_FILE" "${{ inputs.service }}" 2>&1)
            
            read EXTERNAL_PORT INTERNAL_PORT VM_NAME <<< "$CONFIG_OUTPUT"
            
            if [ -z "$EXTERNAL_PORT" ] || [ -z "$INTERNAL_PORT" ]; then
              echo "âŒ ERROR: Failed to parse ports from project.yml!"
              exit 1
            fi
            
            echo "EXTERNAL_PORT=${EXTERNAL_PORT}" >> $GITHUB_ENV
            echo "INTERNAL_PORT=${INTERNAL_PORT}" >> $GITHUB_ENV
            echo "âœ… Loaded ports from project.yml: ${EXTERNAL_PORT}:${INTERNAL_PORT}"
          else
            echo "âŒ ERROR: Parser script not found at: $PARSER_SCRIPT"
            exit 1
          fi
        else
          echo "âŒ ERROR: Project file not found at: $CONFIG_FILE"
          exit 1
        fi
    
    - name: Generate docker-compose for service
      shell: bash
      run: |
        set -e
        
        mkdir -p /opt/apps/${{ inputs.project }}/compose
        
        if [ ! -d "/opt/apps/${{ inputs.project }}/compose" ]; then
          echo "âŒ Failed to create compose directory"
          exit 1
        fi
        
        EXTERNAL_PORT="${EXTERNAL_PORT}"
        INTERNAL_PORT="${INTERNAL_PORT}"
        
        echo "ğŸ”§ Generating compose with ports: ${EXTERNAL_PORT}:${INTERNAL_PORT}"
        
        EXPOSE_PORTS="true"
        
        cat > /opt/apps/${{ inputs.project }}/compose/docker-compose-${{ inputs.service }}.yml <<'EOF'
        version: '3.8'
        
        networks:
          PROJECT_NETWORK:
            external: true
          superdeploy-proxy:
            external: true
        
        services:
          SERVICE_NAME:
            image: IMAGE_PLACEHOLDER
            container_name: CONTAINER_NAME
            restart: unless-stopped
            networks:
              - PROJECT_NETWORK
              - superdeploy-proxy
            PORTS_PLACEHOLDER
            env_file:
              - /tmp/decrypted.env
            labels:
              com.superdeploy.project: "PROJECT_PLACEHOLDER"
              com.superdeploy.service: "SERVICE_PLACEHOLDER"
              com.superdeploy.git.sha: "GIT_SHA_PLACEHOLDER"
              com.superdeploy.git.ref: "GIT_REF_PLACEHOLDER"
              prometheus.scrape: "true"
              prometheus.port: "{{INTERNAL_PORT}}"
              prometheus.path: "/metrics"
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:{{INTERNAL_PORT}}/"]
              interval: 15s
              timeout: 10s
              retries: 5
              start_period: 60s
        EOF
        
        COMPOSE_FILE="/opt/apps/${{ inputs.project }}/compose/docker-compose-${{ inputs.service }}.yml"
        
        if [ "$EXPOSE_PORTS" == "true" ]; then
          sed -i 's#PORTS_PLACEHOLDER#ports:\n        - "'"${EXTERNAL_PORT}:${INTERNAL_PORT}"'"#g' "$COMPOSE_FILE"
        else
          sed -i "s#PORTS_PLACEHOLDER##g" "$COMPOSE_FILE"
        fi
        
        sed -i "s#PROJECT_NETWORK#${{ inputs.project }}-network#g" "$COMPOSE_FILE"
        sed -i "s#SERVICE_NAME#${{ inputs.project }}-${{ inputs.service }}#g" "$COMPOSE_FILE"
        sed -i "s#CONTAINER_NAME#${{ inputs.project }}-${{ inputs.service }}#g" "$COMPOSE_FILE"
        sed -i "s#IMAGE_PLACEHOLDER#${{ inputs.image }}#g" "$COMPOSE_FILE"
        sed -i "s#PROJECT_PLACEHOLDER#${{ inputs.project }}#g" "$COMPOSE_FILE"
        sed -i "s#SERVICE_PLACEHOLDER#${{ inputs.service }}#g" "$COMPOSE_FILE"
        sed -i "s#GIT_SHA_PLACEHOLDER#${{ inputs.git_sha }}#g" "$COMPOSE_FILE"
        sed -i "s#GIT_REF_PLACEHOLDER#${{ inputs.git_ref }}#g" "$COMPOSE_FILE"
        sed -i "s#{{EXTERNAL_PORT}}#${EXTERNAL_PORT}#g" "$COMPOSE_FILE"
        sed -i "s#{{INTERNAL_PORT}}#${INTERNAL_PORT}#g" "$COMPOSE_FILE"
        
        echo "âœ… Generated compose file"
    
    - name: Create networks
      shell: bash
      run: |
        set -e
        echo "ğŸŒ Creating networks..."
        
        if ! docker network ls | grep -q "${{ inputs.project }}-network"; then
          docker network create ${{ inputs.project }}-network || echo "âš ï¸  Network may already exist"
        fi
        
        if ! docker network ls | grep -q "superdeploy-proxy"; then
          docker network create superdeploy-proxy || echo "âš ï¸  Network may already exist"
        fi
        
        echo "âœ… Networks ready"
    
    - name: Deploy service with zero-downtime
      shell: bash
      run: |
        set -ex
        echo "ğŸš€ Deploying service: ${{ inputs.service }}"
        
        PROJECT="${{ inputs.project }}"
        SERVICE="${{ inputs.service }}"
        IMAGE="${{ inputs.image }}"
        GIT_SHA="${{ inputs.git_sha }}"
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        CONTAINER_NAME="${PROJECT}-${SERVICE}"
        
        # Create release directory structure
        RELEASES_DIR="/opt/apps/${PROJECT}/releases/${SERVICE}"
        CURRENT_LINK="/opt/apps/${PROJECT}/current/${SERVICE}"
        RELEASE_DIR="${RELEASES_DIR}/${TIMESTAMP}_${GIT_SHA:0:7}"
        
        mkdir -p "${RELEASES_DIR}"
        mkdir -p "$(dirname ${CURRENT_LINK})"
        mkdir -p "${RELEASE_DIR}"
        
        echo "ğŸ“¦ Release: ${RELEASE_DIR}"
        
        # Copy compose file and env to release directory
        cp /opt/apps/${PROJECT}/compose/docker-compose-${SERVICE}.yml "${RELEASE_DIR}/"
        cp /tmp/decrypted.env "${RELEASE_DIR}/.env"
        
        cd "${RELEASE_DIR}"
        
        echo "ğŸ“¥ Pulling new image: ${IMAGE}"
        docker pull ${IMAGE}
        
        # Check if old container exists
        if docker ps -a --filter "name=${CONTAINER_NAME}" --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
          echo "ğŸ”„ Old container exists, performing zero-downtime update..."
          
          # Stop old container (keeps it for rollback)
          echo "â¸ï¸  Stopping old container..."
          docker stop ${CONTAINER_NAME} || true
          
          # Rename old container for backup
          OLD_BACKUP="${CONTAINER_NAME}-old-$(date +%s)"
          docker rename ${CONTAINER_NAME} ${OLD_BACKUP} || true
          echo "ğŸ’¾ Old container backed up as: ${OLD_BACKUP}"
        fi
        
        # Start new container with same name
        echo "ğŸ³ Starting new container..."
        docker compose -f docker-compose-${SERVICE}.yml up -d --wait
        
        # Wait for container to be ready
        echo "â³ Waiting for container to be ready..."
        sleep 3
        
        # Check if container is running
        if docker ps --filter "name=${CONTAINER_NAME}" --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
          echo "âœ… New container is running"
          
          # Wait a bit more for health check
          sleep 5
          
          # Check health status
          HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' ${CONTAINER_NAME} 2>/dev/null || echo "none")
          
          if [ "$HEALTH_STATUS" = "healthy" ] || [ "$HEALTH_STATUS" = "none" ]; then
            echo "âœ… Container is healthy (status: ${HEALTH_STATUS})"
            
            # Update symlink to new release (atomic operation)
            ln -sfn "${RELEASE_DIR}" "${CURRENT_LINK}"
            echo "âœ… Symlink updated to new release"
            
            # Remove old backup container
            if docker ps -a --filter "name=${OLD_BACKUP}" --format "{{.Names}}" | grep -q "${OLD_BACKUP}"; then
              echo "ğŸ—‘ï¸  Removing old backup container..."
              docker rm -f ${OLD_BACKUP} || true
            fi
            
            # Clean old releases (keep last 5)
            echo "ğŸ§¹ Cleaning old releases..."
            cd "${RELEASES_DIR}"
            ls -t | tail -n +6 | xargs -r rm -rf
            echo "âœ… Kept last 5 releases"
            
          else
            echo "âŒ Health check failed (status: ${HEALTH_STATUS})"
            echo "ğŸ”™ Rolling back to old container..."
            
            # Stop failed container
            docker stop ${CONTAINER_NAME} || true
            docker rm ${CONTAINER_NAME} || true
            
            # Restore old container
            if docker ps -a --filter "name=${OLD_BACKUP}" --format "{{.Names}}" | grep -q "${OLD_BACKUP}"; then
              docker rename ${OLD_BACKUP} ${CONTAINER_NAME}
              docker start ${CONTAINER_NAME}
              echo "âœ… Rolled back to previous version"
            fi
            
            exit 1
          fi
        else
          echo "âŒ Container failed to start"
          
          # Restore old container if exists
          if docker ps -a --filter "name=${OLD_BACKUP}" --format "{{.Names}}" | grep -q "${OLD_BACKUP}"; then
            docker rename ${OLD_BACKUP} ${CONTAINER_NAME}
            docker start ${CONTAINER_NAME}
            echo "âœ… Rolled back to previous version"
          fi
          
          exit 1
        fi
        
        echo "âœ… Zero-downtime deployment complete!"
    
    - name: Verify deployment
      shell: bash
      run: |
        echo "ğŸ” Verifying deployment..."
        
        if docker ps --filter "name=${{ inputs.project }}-${{ inputs.service }}" | grep -q "${{ inputs.project }}-${{ inputs.service }}"; then
          echo "âœ… Container is running"
          docker ps --filter "name=${{ inputs.project }}-${{ inputs.service }}"
          echo "âœ… Deployment successful!"
        else
          echo "âŒ Container not found"
          docker ps -a --filter "name=${{ inputs.project }}-${{ inputs.service }}"
          exit 1
        fi
    
    - name: Check metrics endpoint
      shell: bash
      continue-on-error: true
      run: |
        echo "ğŸ“Š Checking metrics endpoint..."
        
        # Wait for container to be ready
        sleep 3
        
        CONTAINER_NAME="${{ inputs.project }}-${{ inputs.service }}"
        
        # First, install curl in the container if needed
        if ! docker exec $CONTAINER_NAME which curl > /dev/null 2>&1; then
          echo "ğŸ“¦ Installing curl in container..."
          docker exec $CONTAINER_NAME sh -c 'apk add --no-cache curl 2>/dev/null || apt-get update -qq && apt-get install -y -qq curl 2>/dev/null || yum install -y -q curl 2>/dev/null || echo "Could not install curl"'
        fi
        
        # Check if curl is now available
        if docker exec $CONTAINER_NAME which curl > /dev/null 2>&1; then
          # Check if /metrics endpoint exists (with 5 second timeout)
          METRICS_CHECK=$(timeout 5 docker exec $CONTAINER_NAME curl -s -o /dev/null -w "%{http_code}" http://localhost:${INTERNAL_PORT}/metrics 2>/dev/null || echo "000")
          
          if [ "$METRICS_CHECK" = "200" ]; then
            echo "âœ… Metrics endpoint is available at /metrics"
            echo "ğŸ“ˆ Grafana: Endpoint Analytics dashboard will show this service"
          elif [ "$METRICS_CHECK" = "404" ]; then
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“Š METRICS NOT CONFIGURED"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            echo "To enable endpoint analytics in Grafana, add metrics to your app:"
            echo ""
            echo "1. Add to requirements.txt:"
            echo "   prometheus-client==0.19.0"
            echo ""
            echo "2. Add to your app.py:"
            echo "   from prometheus_client import make_asgi_app, Counter"
            echo "   metrics_app = make_asgi_app()"
            echo "   app.mount(\"/metrics\", metrics_app)"
            echo ""
            echo "3. Redeploy:"
            echo "   git push origin production"
            echo ""
            echo "ğŸ“– Docs: https://prometheus.github.io/client_python/"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
          else
            echo "âš ï¸  Could not check metrics endpoint (service may not be responding)"
          fi
        else
          echo "âš ï¸  curl not available in container, skipping metrics check"
        fi
    
    - name: Clean up secrets
      if: always()
      shell: bash
      run: |
        rm -f /tmp/decrypted.env
        rm -f /tmp/encrypted.age
        echo "âœ… Secrets cleaned up"

