name: 'Deploy to VM'
description: 'Deploy a service to VM using Docker Compose'
author: 'Superdeploy Team'

inputs:
  project:
    description: 'Project name (e.g., cheapa)'
    required: true
  service:
    description: 'Service name (e.g., api, dashboard, services)'
    required: true
  image:
    description: 'Docker image with tag'
    required: true
  env_bundle:
    description: 'AGE-encrypted environment variables bundle (base64)'
    required: true
  git_sha:
    description: 'Git commit SHA'
    required: true
  git_ref:
    description: 'Git ref (branch/tag)'
    required: true
    default: 'production'

runs:
  using: 'composite'
  steps:
    - name: Setup age tool
      shell: bash
      run: |
        if ! command -v age &> /dev/null; then
          echo "Installing age..."
          curl -sL https://github.com/FiloSottile/age/releases/download/v1.1.1/age-v1.1.1-linux-amd64.tar.gz | tar xz
          chmod +x age/age
          export PATH="$PWD/age:$PATH"
          echo "$PWD/age" >> $GITHUB_PATH
        fi
        age --version
    
    - name: Decrypt environment bundle
      shell: bash
      run: |
        set -ex
        echo "üîê Decrypting environment bundle..."
        echo "${{ inputs.env_bundle }}" | base64 -d > /tmp/encrypted.age
        echo "‚úÖ Base64 decoded successfully"
        
        echo "$AGE_SECRET_KEY" > /tmp/age-key.txt
        age -d -i /tmp/age-key.txt /tmp/encrypted.age > /tmp/decrypted.env
        rm /tmp/age-key.txt
        echo "‚úÖ AGE decryption successful"
        
        echo "üìã Decrypted env file contents (first 5 lines, masked):"
        head -5 /tmp/decrypted.env | sed 's/=.*/=***MASKED***/g'
        
        rm /tmp/encrypted.age
        echo "‚úÖ Decrypt step completed"
    
    - name: Load environment variables
      shell: bash
      run: |
        set -ex
        echo "üì• Loading environment variables..."
        
        if [ ! -f /tmp/decrypted.env ] || [ ! -s /tmp/decrypted.env ]; then
          echo "‚ùå Decrypted env file not found or empty!"
          exit 1
        fi
        
        set -a
        source /tmp/decrypted.env
        set +a
        
        echo "‚úÖ Environment sourced successfully"
        
        # Save to GitHub env for next steps
        grep -v '^#' /tmp/decrypted.env | grep -v '^$' >> $GITHUB_ENV
        
        echo "üìä Total env vars loaded: $(grep -v '^#' /tmp/decrypted.env | grep -v '^$' | wc -l)"
        echo "‚úÖ Load env step completed"
    
    - name: Login to Docker Hub
      shell: bash
      run: |
        set -ex
        echo "üê≥ Logging in to Docker Hub..."
        
        if [ -z "$DOCKER_USERNAME" ] || [ -z "$DOCKER_TOKEN" ]; then
          echo "‚ùå Docker Hub credentials not found!"
          exit 1
        fi
        
        echo "$DOCKER_TOKEN" | docker login docker.io -u "$DOCKER_USERNAME" --password-stdin
        
        if [ $? -eq 0 ]; then
          echo "‚úÖ Docker Hub login successful"
        else
          echo "‚ùå Docker Hub login failed!"
          exit 1
        fi
    
    - name: Load project configuration
      shell: bash
      run: |
        set -ex
        echo "üìã Loading project configuration..."
        
        CONFIG_FILE="/tmp/project.yml"
        
        # Use project.yml from checked out repo (workspace)
        if [ -f "${GITHUB_WORKSPACE}/projects/${{ inputs.project }}/project.yml" ]; then
          cp "${GITHUB_WORKSPACE}/projects/${{ inputs.project }}/project.yml" "$CONFIG_FILE"
          echo "‚úÖ Successfully loaded project.yml from workspace"
        else
          echo "‚ùå ERROR: project.yml not found in workspace"
          echo "Tried: ${GITHUB_WORKSPACE}/projects/${{ inputs.project }}/project.yml"
          exit 1
        fi
        
        if [ -f "$CONFIG_FILE" ]; then
          PARSER_SCRIPT="${GITHUB_WORKSPACE}/.forgejo/scripts/parse_config.py"
          
          if [ -f "$PARSER_SCRIPT" ]; then
            echo "‚úÖ Parser script found"
            CONFIG_OUTPUT=$(python3 "$PARSER_SCRIPT" "$CONFIG_FILE" "${{ inputs.service }}" 2>&1)
            
            read EXTERNAL_PORT INTERNAL_PORT VM_NAME <<< "$CONFIG_OUTPUT"
            
            if [ -z "$EXTERNAL_PORT" ] || [ -z "$INTERNAL_PORT" ]; then
              echo "‚ùå ERROR: Failed to parse ports from project.yml!"
              exit 1
            fi
            
            echo "EXTERNAL_PORT=${EXTERNAL_PORT}" >> $GITHUB_ENV
            echo "INTERNAL_PORT=${INTERNAL_PORT}" >> $GITHUB_ENV
            echo "‚úÖ Loaded ports from project.yml: ${EXTERNAL_PORT}:${INTERNAL_PORT}"
          else
            echo "‚ùå ERROR: Parser script not found at: $PARSER_SCRIPT"
            exit 1
          fi
        else
          echo "‚ùå ERROR: Project file not found at: $CONFIG_FILE"
          exit 1
        fi
    
    - name: Generate docker-compose for service
      shell: bash
      run: |
        set -e
        
        mkdir -p /opt/apps/${{ inputs.project }}/compose
        
        if [ ! -d "/opt/apps/${{ inputs.project }}/compose" ]; then
          echo "‚ùå Failed to create compose directory"
          exit 1
        fi
        
        EXTERNAL_PORT="${EXTERNAL_PORT}"
        INTERNAL_PORT="${INTERNAL_PORT}"
        
        echo "üîß Generating compose with ports: ${EXTERNAL_PORT}:${INTERNAL_PORT}"
        
        EXPOSE_PORTS="true"
        
        cat > /opt/apps/${{ inputs.project }}/compose/docker-compose-${{ inputs.service }}.yml <<'EOF'
        version: '3.8'
        
        networks:
          PROJECT_NETWORK:
            external: true
          superdeploy-proxy:
            external: true
        
        services:
          SERVICE_NAME:
            image: IMAGE_PLACEHOLDER
            container_name: CONTAINER_NAME
            restart: unless-stopped
            networks:
              - PROJECT_NETWORK
              - superdeploy-proxy
            PORTS_PLACEHOLDER
            env_file:
              - /tmp/decrypted.env
            labels:
              com.superdeploy.project: "PROJECT_PLACEHOLDER"
              com.superdeploy.service: "SERVICE_PLACEHOLDER"
              com.superdeploy.git.sha: "GIT_SHA_PLACEHOLDER"
              com.superdeploy.git.ref: "GIT_REF_PLACEHOLDER"
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:{{INTERNAL_PORT}}/"]
              interval: 15s
              timeout: 10s
              retries: 5
              start_period: 60s
        EOF
        
        COMPOSE_FILE="/opt/apps/${{ inputs.project }}/compose/docker-compose-${{ inputs.service }}.yml"
        
        if [ "$EXPOSE_PORTS" == "true" ]; then
          sed -i 's#PORTS_PLACEHOLDER#ports:\n        - "'"${EXTERNAL_PORT}:${INTERNAL_PORT}"'"#g' "$COMPOSE_FILE"
        else
          sed -i "s#PORTS_PLACEHOLDER##g" "$COMPOSE_FILE"
        fi
        
        sed -i "s#PROJECT_NETWORK#${{ inputs.project }}-network#g" "$COMPOSE_FILE"
        sed -i "s#SERVICE_NAME#${{ inputs.project }}-${{ inputs.service }}#g" "$COMPOSE_FILE"
        sed -i "s#CONTAINER_NAME#${{ inputs.project }}-${{ inputs.service }}#g" "$COMPOSE_FILE"
        sed -i "s#IMAGE_PLACEHOLDER#${{ inputs.image }}#g" "$COMPOSE_FILE"
        sed -i "s#PROJECT_PLACEHOLDER#${{ inputs.project }}#g" "$COMPOSE_FILE"
        sed -i "s#SERVICE_PLACEHOLDER#${{ inputs.service }}#g" "$COMPOSE_FILE"
        sed -i "s#GIT_SHA_PLACEHOLDER#${{ inputs.git_sha }}#g" "$COMPOSE_FILE"
        sed -i "s#GIT_REF_PLACEHOLDER#${{ inputs.git_ref }}#g" "$COMPOSE_FILE"
        sed -i "s#{{EXTERNAL_PORT}}#${EXTERNAL_PORT}#g" "$COMPOSE_FILE"
        sed -i "s#{{INTERNAL_PORT}}#${INTERNAL_PORT}#g" "$COMPOSE_FILE"
        
        echo "‚úÖ Generated compose file"
    
    - name: Create networks
      shell: bash
      run: |
        set -e
        echo "üåê Creating networks..."
        
        if ! docker network ls | grep -q "${{ inputs.project }}-network"; then
          docker network create ${{ inputs.project }}-network || echo "‚ö†Ô∏è  Network may already exist"
        fi
        
        if ! docker network ls | grep -q "superdeploy-proxy"; then
          docker network create superdeploy-proxy || echo "‚ö†Ô∏è  Network may already exist"
        fi
        
        echo "‚úÖ Networks ready"
    
    - name: Deploy service with zero-downtime
      shell: bash
      run: |
        set -ex
        echo "üöÄ Deploying service: ${{ inputs.service }}"
        
        PROJECT="${{ inputs.project }}"
        SERVICE="${{ inputs.service }}"
        IMAGE="${{ inputs.image }}"
        GIT_SHA="${{ inputs.git_sha }}"
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        CONTAINER_NAME="${PROJECT}-${SERVICE}"
        
        # Create release directory structure
        RELEASES_DIR="/opt/apps/${PROJECT}/releases/${SERVICE}"
        CURRENT_LINK="/opt/apps/${PROJECT}/current/${SERVICE}"
        RELEASE_DIR="${RELEASES_DIR}/${TIMESTAMP}_${GIT_SHA:0:7}"
        
        mkdir -p "${RELEASES_DIR}"
        mkdir -p "$(dirname ${CURRENT_LINK})"
        mkdir -p "${RELEASE_DIR}"
        
        echo "üì¶ Release: ${RELEASE_DIR}"
        
        # Copy compose file and env to release directory
        cp /opt/apps/${PROJECT}/compose/docker-compose-${SERVICE}.yml "${RELEASE_DIR}/"
        cp /tmp/decrypted.env "${RELEASE_DIR}/.env"
        
        cd "${RELEASE_DIR}"
        
        echo "üì• Pulling new image: ${IMAGE}"
        docker pull ${IMAGE}
        
        # Check if old container exists
        if docker ps -a --filter "name=${CONTAINER_NAME}" --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
          echo "üîÑ Old container exists, performing zero-downtime update..."
          
          # Stop old container (keeps it for rollback)
          echo "‚è∏Ô∏è  Stopping old container..."
          docker stop ${CONTAINER_NAME} || true
          
          # Rename old container for backup
          OLD_BACKUP="${CONTAINER_NAME}-old-$(date +%s)"
          docker rename ${CONTAINER_NAME} ${OLD_BACKUP} || true
          echo "üíæ Old container backed up as: ${OLD_BACKUP}"
        fi
        
        # Start new container with same name
        echo "üê≥ Starting new container..."
        docker compose -f docker-compose-${SERVICE}.yml up -d --wait
        
        # Wait for container to be ready
        echo "‚è≥ Waiting for container to be ready..."
        sleep 3
        
        # Check if container is running
        if docker ps --filter "name=${CONTAINER_NAME}" --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
          echo "‚úÖ New container is running"
          
          # Wait a bit more for health check
          sleep 5
          
          # Check health status
          HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' ${CONTAINER_NAME} 2>/dev/null || echo "none")
          
          if [ "$HEALTH_STATUS" = "healthy" ] || [ "$HEALTH_STATUS" = "none" ]; then
            echo "‚úÖ Container is healthy (status: ${HEALTH_STATUS})"
            
            # Update symlink to new release (atomic operation)
            ln -sfn "${RELEASE_DIR}" "${CURRENT_LINK}"
            echo "‚úÖ Symlink updated to new release"
            
            # Remove old backup container
            if docker ps -a --filter "name=${OLD_BACKUP}" --format "{{.Names}}" | grep -q "${OLD_BACKUP}"; then
              echo "üóëÔ∏è  Removing old backup container..."
              docker rm -f ${OLD_BACKUP} || true
            fi
            
            # Clean old releases (keep last 5)
            echo "üßπ Cleaning old releases..."
            cd "${RELEASES_DIR}"
            ls -t | tail -n +6 | xargs -r rm -rf
            echo "‚úÖ Kept last 5 releases"
            
          else
            echo "‚ùå Health check failed (status: ${HEALTH_STATUS})"
            echo "üîô Rolling back to old container..."
            
            # Stop failed container
            docker stop ${CONTAINER_NAME} || true
            docker rm ${CONTAINER_NAME} || true
            
            # Restore old container
            if docker ps -a --filter "name=${OLD_BACKUP}" --format "{{.Names}}" | grep -q "${OLD_BACKUP}"; then
              docker rename ${OLD_BACKUP} ${CONTAINER_NAME}
              docker start ${CONTAINER_NAME}
              echo "‚úÖ Rolled back to previous version"
            fi
            
            exit 1
          fi
        else
          echo "‚ùå Container failed to start"
          
          # Restore old container if exists
          if docker ps -a --filter "name=${OLD_BACKUP}" --format "{{.Names}}" | grep -q "${OLD_BACKUP}"; then
            docker rename ${OLD_BACKUP} ${CONTAINER_NAME}
            docker start ${CONTAINER_NAME}
            echo "‚úÖ Rolled back to previous version"
          fi
          
          exit 1
        fi
        
        echo "‚úÖ Zero-downtime deployment complete!"
    
    - name: Verify deployment
      shell: bash
      run: |
        echo "üîç Verifying deployment..."
        
        if docker ps --filter "name=${{ inputs.project }}-${{ inputs.service }}" | grep -q "${{ inputs.project }}-${{ inputs.service }}"; then
          echo "‚úÖ Container is running"
          docker ps --filter "name=${{ inputs.project }}-${{ inputs.service }}"
          echo "‚úÖ Deployment successful!"
        else
          echo "‚ùå Container not found"
          docker ps -a --filter "name=${{ inputs.project }}-${{ inputs.service }}"
          exit 1
        fi
    
    - name: Send deployment notification email
      if: success()
      shell: bash
      run: |
        # Check if SMTP is configured
        if [ -z "$SMTP_USERNAME" ] || [ -z "$SMTP_PASSWORD" ] || [ -z "$ALERT_EMAIL" ]; then
          echo "‚ö†Ô∏è  SMTP not configured, skipping email notification"
          exit 0
        fi
        
        echo "üìß Sending deployment notification..."
        
        # Get deployment info
        PROJECT="${{ inputs.project }}"
        SERVICE="${{ inputs.service }}"
        GIT_SHA="${{ inputs.git_sha }}"
        GIT_REF="${{ inputs.git_ref }}"
        TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
        
        # Create email body
        cat > /tmp/email.txt <<EOF
        Subject: ‚úÖ Deployment Success: ${PROJECT}/${SERVICE}
        From: SuperDeploy <${SMTP_USERNAME}>
        To: ${ALERT_EMAIL}
        Content-Type: text/html; charset=UTF-8
        
        <html>
        <body style="font-family: Arial, sans-serif; padding: 20px;">
          <h2 style="color: #28a745;">‚úÖ Deployment Successful</h2>
          <table style="border-collapse: collapse; width: 100%; max-width: 600px;">
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Project</strong></td>
              <td style="padding: 8px; border: 1px solid #ddd;">${PROJECT}</td>
            </tr>
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Service</strong></td>
              <td style="padding: 8px; border: 1px solid #ddd;">${SERVICE}</td>
            </tr>
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Git SHA</strong></td>
              <td style="padding: 8px; border: 1px solid #ddd;"><code>${GIT_SHA:0:7}</code></td>
            </tr>
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Branch</strong></td>
              <td style="padding: 8px; border: 1px solid #ddd;">${GIT_REF}</td>
            </tr>
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Deployed At</strong></td>
              <td style="padding: 8px; border: 1px solid #ddd;">${TIMESTAMP}</td>
            </tr>
          </table>
          <p style="margin-top: 20px; color: #666;">
            <small>Automated deployment notification from SuperDeploy</small>
          </p>
        </body>
        </html>
        EOF
        
        # Send email using curl
        curl --ssl-reqd \
          --url "smtp://${SMTP_HOST}:${SMTP_PORT}" \
          --user "${SMTP_USERNAME}:${SMTP_PASSWORD}" \
          --mail-from "${SMTP_USERNAME}" \
          --mail-rcpt "${ALERT_EMAIL}" \
          --upload-file /tmp/email.txt \
          --silent --show-error
        
        if [ $? -eq 0 ]; then
          echo "‚úÖ Email notification sent to ${ALERT_EMAIL}"
        else
          echo "‚ö†Ô∏è  Failed to send email notification"
        fi
        
        rm -f /tmp/email.txt
    
    - name: Send failure notification email
      if: failure()
      shell: bash
      run: |
        # Check if SMTP is configured
        if [ -z "$SMTP_USERNAME" ] || [ -z "$SMTP_PASSWORD" ] || [ -z "$ALERT_EMAIL" ]; then
          echo "‚ö†Ô∏è  SMTP not configured, skipping email notification"
          exit 0
        fi
        
        echo "üìß Sending failure notification..."
        
        PROJECT="${{ inputs.project }}"
        SERVICE="${{ inputs.service }}"
        GIT_SHA="${{ inputs.git_sha }}"
        TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
        
        cat > /tmp/email.txt <<EOF
        Subject: ‚ùå Deployment Failed: ${PROJECT}/${SERVICE}
        From: SuperDeploy <${SMTP_USERNAME}>
        To: ${ALERT_EMAIL}
        Content-Type: text/html; charset=UTF-8
        
        <html>
        <body style="font-family: Arial, sans-serif; padding: 20px;">
          <h2 style="color: #dc3545;">‚ùå Deployment Failed</h2>
          <table style="border-collapse: collapse; width: 100%; max-width: 600px;">
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Project</strong></td>
              <td style="padding: 8px; border: 1px solid #ddd;">${PROJECT}</td>
            </tr>
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Service</strong></td>
              <td style="padding: 8px; border: 1px solid #ddd;">${SERVICE}</td>
            </tr>
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Git SHA</strong></td>
              <td style="padding: 8px; border: 1px solid #ddd;"><code>${GIT_SHA:0:7}</code></td>
            </tr>
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Failed At</strong></td>
              <td style="padding: 8px; border: 1px solid #ddd;">${TIMESTAMP}</td>
            </tr>
          </table>
          <p style="margin-top: 20px;">
            <strong>Action Required:</strong> Check Forgejo logs for details.
          </p>
          <p style="color: #666;">
            <small>Automated deployment notification from SuperDeploy</small>
          </p>
        </body>
        </html>
        EOF
        
        curl --ssl-reqd \
          --url "smtp://${SMTP_HOST}:${SMTP_PORT}" \
          --user "${SMTP_USERNAME}:${SMTP_PASSWORD}" \
          --mail-from "${SMTP_USERNAME}" \
          --mail-rcpt "${ALERT_EMAIL}" \
          --upload-file /tmp/email.txt \
          --silent --show-error
        
        rm -f /tmp/email.txt
    
    - name: Clean up secrets
      if: always()
      shell: bash
      run: |
        rm -f /tmp/decrypted.env
        rm -f /tmp/encrypted.age
        echo "‚úÖ Secrets cleaned up"

