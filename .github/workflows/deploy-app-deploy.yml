name: Reusable - Deploy App

on:
  workflow_call:
    inputs:
      project:
        description: 'Project name'
        required: true
        type: string
      app:
        description: 'App name'
        required: true
        type: string
      vm_role:
        description: 'VM role'
        required: true
        type: string
      docker_org:
        description: 'Docker organization name'
        required: true
        type: string
      docker_username_var:
        description: 'GitHub variable name for Docker username'
        required: false
        type: string
        default: 'DOCKER_USERNAME'
    secrets:
      REPOSITORY_TOKEN:
        required: true

jobs:
  deploy:
    name: Deploy service (zero-downtime with replicas)
    environment: ${{ github.ref_name }}
    runs-on:
      - self-hosted
      - superdeploy
      - ${{ inputs.project }}
      - ${{ inputs.vm_role }}

    steps:
      - name: Download workspace artifact
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: ${{ github.workspace }}

      - name: Validate runner
        run: |
          echo "ðŸ” Validating deployment environment..."

          if [ ! -f /opt/superdeploy/.project ]; then
            echo "âŒ ERROR: /opt/superdeploy/.project not found!"
            exit 1
          fi

          RUNNER_PROJECT=$(cat /opt/superdeploy/.project)
          if [ "$RUNNER_PROJECT" != "${{ inputs.project }}" ]; then
            echo "âŒ ERROR: Wrong project! Expected ${{ inputs.project }}, got $RUNNER_PROJECT"
            exit 1
          fi

          echo "âœ… Correct VM for project: $RUNNER_PROJECT"

      - name: Create .env from GitHub Environment Secrets
        env:
          SECRETS_JSON: ${{ toJSON(secrets) }}
        run: |
          APP_NAME="${{ inputs.app }}"
          PROJECT="${{ inputs.project }}"
          ENV_DIR="/opt/superdeploy/projects/$PROJECT/data/$APP_NAME"

          echo "ðŸ“ Creating .env from GitHub secrets..."
          sudo mkdir -p "$ENV_DIR"

          # Get all secrets from GitHub and convert to .env format
          echo "$SECRETS_JSON" | jq -r 'to_entries[] | "\(.key)=\(.value)"' > /tmp/final.env

          sudo cp /tmp/final.env "$ENV_DIR/.env"
          sudo chown superdeploy:superdeploy "$ENV_DIR/.env"
          sudo chmod 600 "$ENV_DIR/.env"

          echo "âœ… Environment file created at $ENV_DIR/.env"
          echo "ðŸ“Š Total variables: $(wc -l < "$ENV_DIR/.env")"

      - name: Update docker-compose.yml from marker file
        run: |
          APP_NAME="${{ inputs.app }}"
          PROJECT="${{ inputs.project }}"
          COMPOSE_FILE="/opt/superdeploy/projects/$PROJECT/compose/docker-compose.yml"
          
          # Find marker file (might be in api/ or other app directory)
          MARKER_FILE=$(find "$GITHUB_WORKSPACE" -name "superdeploy" -type f | head -1)

          echo "ðŸ”„ Updating docker-compose.yml for $APP_NAME from marker..."
          echo "ðŸ“ Marker file: $MARKER_FILE"
          echo "ðŸ“ GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
          echo "ðŸ“ Checking if marker file exists..."

          if [ -z "$MARKER_FILE" ] || [ ! -f "$MARKER_FILE" ]; then
            echo "âŒ ERROR: Marker file not found"
            echo "ðŸ“ Current directory: $(pwd)"
            echo "ðŸ“ Listing GITHUB_WORKSPACE:"
            ls -la "$GITHUB_WORKSPACE/" || true
            find "$GITHUB_WORKSPACE" -name "superdeploy" -type f || true
            exit 1
          fi

          echo "âœ… Marker file found!"

          sudo python3 - "$APP_NAME" "$COMPOSE_FILE" "$MARKER_FILE" << 'PYSCRIPT'
          import yaml
          import sys

          app_name = sys.argv[1]
          compose_file = sys.argv[2]
          marker_file = sys.argv[3]

          try:
              with open(marker_file, 'r') as f:
                  marker = yaml.safe_load(f)

              with open(compose_file, 'r') as f:
                  compose = yaml.safe_load(f)

              # Extract project name from marker file
              project_name = marker.get('project', app_name)

              # Ensure services exists
              if compose.get('services') is None:
                  compose['services'] = {}

              # Get processes from marker file (nested under 'processes' key)
              processes = marker.get('processes', {})
              if not processes:
                  print(f"âš ï¸  WARNING: No processes found in marker file")
                  sys.exit(0)

              for process_name, process_config in processes.items():
                  service_name = f"{app_name}-{process_name}"
                  replicas = process_config.get('replicas', 1)
                  port = process_config.get('port')
                  command = process_config.get('command', '')

                  # Create or update service
                  if service_name not in compose['services']:
                      # CREATE NEW SERVICE
                      compose['services'][service_name] = {
                          'image': f"docker.io/${{ inputs.docker_org }}/{app_name}:latest",
                          'command': command,
                          'env_file': f"/opt/superdeploy/projects/{project_name}/data/{app_name}/.env",
                          'volumes': [
                              f"/opt/superdeploy/projects/{project_name}/data/{app_name}:/app/data",
                              f"/opt/superdeploy/projects/{project_name}/logs/{app_name}:/app/logs"
                          ],
                          'networks': {
                              f"{project_name}-network": {
                                  'aliases': [f"{app_name}-{process_name}"]
                              }
                          },
                          'deploy': {
                              'mode': 'replicated',
                              'replicas': replicas,
                              'update_config': {
                                  'parallelism': 1,
                                  'delay': '10s',
                                  'order': 'start-first',
                                  'failure_action': 'rollback'
                              },
                              'restart_policy': {
                                  'condition': 'on-failure',
                                  'delay': '5s',
                                  'max_attempts': 3
                              }
                          }
                      }
                      if port:
                          # Use expose for internal network only (Caddy handles external routing)
                          compose['services'][service_name]['expose'] = [str(port)]
                      print(f"âœ… Created {service_name}: replicas={replicas}, port={port}, command={command}")
                  else:
                      # UPDATE EXISTING SERVICE
                      service = compose['services'][service_name]

                      # Update command from marker file
                      service['command'] = command

                      if 'deploy' not in service:
                          service['deploy'] = {}
                      service['deploy']['replicas'] = replicas

                      if port:
                          service.pop('ports', None)
                          service.pop('expose', None)
                          # Use expose for internal network only (Caddy handles external routing)
                          service['expose'] = [str(port)]

                      # Safely handle networks
                      network_alias = f"{app_name}-{process_name}"
                      network_name = f"{project_name}-network"

                      if not isinstance(service.get('networks'), dict):
                          service['networks'] = {}

                      if network_name not in service['networks'] or not isinstance(service['networks'].get(network_name), dict):
                          service['networks'][network_name] = {'aliases': []}

                      if 'aliases' not in service['networks'][network_name]:
                          service['networks'][network_name]['aliases'] = []
                      if network_alias not in service['networks'][network_name]['aliases']:
                          service['networks'][network_name]['aliases'].append(network_alias)

                      print(f"âœ… Updated {service_name}: replicas={replicas}, port={port}")

              with open(compose_file, 'w') as f:
                  yaml.dump(compose, f, default_flow_style=False, sort_keys=False)

              print(f"âœ… docker-compose.yml updated for {app_name}")

          except Exception as e:
              import traceback
              print(f"âš ï¸  Failed to update compose: {e}")
              print(f"âš ï¸  Traceback:")
              traceback.print_exc()
              print(f"âš ï¸  Will use existing compose file")
              sys.exit(0)
          PYSCRIPT

      - name: Deploy application (zero-downtime with replicas)
        run: |
          cd /opt/superdeploy/projects/${{ inputs.project }}/compose

          APP_NAME="${{ inputs.app }}"

          # Debug: Show docker-compose.yml content
          echo "ðŸ” DEBUG: docker-compose.yml content:"
          cat docker-compose.yml | head -20

          # Check if any process services exist for this app (pattern: app-*)
          if ! grep -q "^  ${APP_NAME}-" docker-compose.yml; then
            echo "âš ï¸  WARNING: No services found for ${APP_NAME} in docker-compose.yml"
            echo "âš ï¸  This might be first deployment - continuing anyway..."
          fi

          # Create empty .env files for other apps to prevent docker-compose errors
          for app_dir in ../data/*/; do
            if [ -d "$app_dir" ]; then
              app_name=$(basename "$app_dir")
              env_file="../data/$app_name/.env"
              if [ ! -f "$env_file" ]; then
                echo "# Placeholder .env for $app_name" > "$env_file"
                echo "ðŸ“ Created placeholder .env for $app_name"
              fi
            fi
          done

          # Get all process services for this app
          SERVICES=$(grep "^  ${APP_NAME}-" docker-compose.yml | cut -d: -f1 | xargs)
          echo "ðŸ” Detected services: $SERVICES"

          echo "ðŸš€ Starting zero-downtime deployment with replicas..."

          # Pull new image first (same image for all processes)
          echo "ðŸ“¦ Step 1/3: Pulling new image..."
          docker pull ${{ inputs.docker_org }}/${APP_NAME}:latest

          # Deploy all process services with Docker Compose rolling update
          echo "ðŸš€ Step 2/3: Deploying all processes (rolling update)..."
          for service in $SERVICES; do
            echo "  Deploying $service..."

            # Stop and remove old containers first to prevent port conflicts
            echo "  ðŸ§¹ Cleaning up old containers for $service..."
            docker compose ps -q $service | xargs -r docker stop 2>/dev/null || true
            docker compose ps -aq $service | xargs -r docker rm -f 2>/dev/null || true

            # Wait a moment for ports to be released
            sleep 2

            docker compose up -d --no-deps $service
          done

          # Wait for deployment to stabilize
          echo "â³ Step 3/3: Health check (waiting for all replicas)..."
          sleep 10

          # Check status for all process services
          TOTAL_RUNNING=0
          TOTAL_EXPECTED=0
          for service in $SERVICES; do
            RUNNING=$(docker compose ps $service --status running --format '{{.Name}}' 2>/dev/null | wc -l)
            EXPECTED=$(docker compose ps $service --format '{{.Name}}' 2>/dev/null | wc -l)
            TOTAL_RUNNING=$((TOTAL_RUNNING + RUNNING))
            TOTAL_EXPECTED=$((TOTAL_EXPECTED + EXPECTED))
            echo "  $service: $RUNNING/$EXPECTED replicas running"
          done

          if [ "$TOTAL_RUNNING" -ge "1" ]; then
            echo "âœ… Deployment successful! ($TOTAL_RUNNING/$TOTAL_EXPECTED total replicas running)"

            # Show logs from first service
            FIRST_SERVICE=$(echo $SERVICES | awk '{print $1}')
            FIRST_CONTAINER=$(docker compose ps $FIRST_SERVICE --format '{{.Name}}' 2>/dev/null | head -1)
            if [ -n "$FIRST_CONTAINER" ]; then
              echo ""
              echo "ðŸ“‹ Recent logs from $FIRST_CONTAINER:"
              docker logs $FIRST_CONTAINER --tail 20 2>/dev/null || true
            fi
          else
            echo "âŒ Deployment failed - no replicas running"
            echo ""
            echo "ðŸ“‹ Service logs:"
            for service in $SERVICES; do
              echo "=== $service ==="
              docker compose logs $service --tail 20
            done
            exit 1
          fi

          # Cleanup old images
          docker image prune -f >/dev/null 2>&1 || true

      - name: Calculate and update version
        run: |
          PROJECT_DIR="/opt/superdeploy/projects/${{ inputs.project }}"
          RELEASES_FILE="$PROJECT_DIR/releases.json"
          APP_NAME="${{ inputs.app }}"

          # Initialize releases.json if it doesn't exist
          sudo mkdir -p "$PROJECT_DIR"
          if [ ! -f "$RELEASES_FILE" ]; then
            echo "{}" | sudo tee "$RELEASES_FILE" > /dev/null
            sudo chown superdeploy:superdeploy "$RELEASES_FILE"
            sudo chmod 644 "$RELEASES_FILE"
          fi

          # Get current version from last release
          CURRENT_VERSION=$(sudo cat "$RELEASES_FILE" | jq -r --arg app "$APP_NAME" '.[$app][-1].version // "0.0.0"')
          echo "Current version: $CURRENT_VERSION"

          # Determine version bump type from commit message
          COMMIT_MSG="${{ github.event.head_commit.message }}"

          if echo "$COMMIT_MSG" | grep -qiE '^\[major\]|^breaking:'; then
            BUMP_TYPE="major"
          elif echo "$COMMIT_MSG" | grep -qiE '^\[minor\]|^feat:'; then
            BUMP_TYPE="minor"
          else
            BUMP_TYPE="patch"
          fi

          echo "Bump type: $BUMP_TYPE"

          # Parse and increment version
          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"

          case $BUMP_TYPE in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac

          NEW_VERSION="$major.$minor.$patch"
          DEPLOYED_AT=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          echo "New version: $NEW_VERSION"
          echo "ðŸ“Œ Updating version: $APP_NAME v$NEW_VERSION"

          # Create new release entry
          NEW_RELEASE=$(jq -n --arg ver "$NEW_VERSION" --arg deployed "$DEPLOYED_AT" --arg sha "${{ github.sha }}" --arg actor "${{ github.actor }}" --arg branch "${{ github.ref_name }}" --arg commit "${{ github.event.head_commit.message }}" '{
            version: $ver,
            deployed_at: $deployed,
            git_sha: $sha,
            deployed_by: $actor,
            branch: $branch,
            commit_message: $commit
          }')

          # Append to releases array for this app (keep last 5)
          UPDATED_RELEASES=$(sudo cat "$RELEASES_FILE" | jq --argjson release "$NEW_RELEASE" --arg app "$APP_NAME" '
            .[$app] = ((.[$app] // []) + [$release])[-5:]
          ')

          echo "$UPDATED_RELEASES" | sudo tee "$RELEASES_FILE" > /dev/null
          sudo chown superdeploy:superdeploy "$RELEASES_FILE"
          sudo chmod 644 "$RELEASES_FILE"

          echo "âœ… Version tracked: v$NEW_VERSION (release history updated)"

      - name: Run deployment hooks
        run: |
          cd /opt/superdeploy/projects/${{ inputs.project }}

          if [ ! -f config.yml ]; then
            echo "â­ï¸  No config.yml found, skipping hooks"
            exit 0
          fi

          APP_NAME="${{ inputs.app }}"

          cat > /tmp/read_hooks.py <<'PYEOF'
          import yaml
          import sys
          import os

          try:
              with open('config.yml') as f:
                  config = yaml.safe_load(f)
              app_name = os.environ.get('APP_NAME', '')
              hooks = config.get('apps', {}).get(app_name, {}).get('hooks', {})
              after_deploy = hooks.get('after_deploy', [])
              if after_deploy:
                  for cmd in after_deploy:
                      print(cmd)
          except Exception:
              sys.exit(0)
          PYEOF

          HOOKS=$(APP_NAME="$APP_NAME" python3 /tmp/read_hooks.py)

          if [ -z "$HOOKS" ]; then
            echo "â­ï¸  No post-deployment hooks configured for ${{ inputs.app }}"
            exit 0
          fi

          echo "ðŸ”§ Running post-deployment hooks for ${{ inputs.app }}..."
          cd compose

          # Find first web or release process service for running hooks
          HOOK_SERVICE=$(grep "^  ${APP_NAME}-\(web\|release\)" docker-compose.yml | head -1 | cut -d: -f1 | xargs)

          if [ -z "$HOOK_SERVICE" ]; then
            # Fallback: use first available service
            HOOK_SERVICE=$(grep "^  ${APP_NAME}-" docker-compose.yml | head -1 | cut -d: -f1 | xargs)
          fi

          echo "ðŸ“ Running hooks on service: $HOOK_SERVICE"

          FAILED=0
          echo "$HOOKS" | while IFS= read -r cmd; do
            if [ -n "$cmd" ]; then
              echo "â–¶ Running: $cmd"
              if ! docker compose exec -T $HOOK_SERVICE $cmd; then
                echo "âš ï¸  Hook failed: $cmd"
                FAILED=1
              fi
            fi
          done

          if [ $FAILED -eq 1 ]; then
            echo "âŒ Post-deployment hooks failed"
            exit 1
          fi

          echo "âœ… Post-deployment hooks completed"

