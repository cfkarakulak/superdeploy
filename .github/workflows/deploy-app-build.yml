name: Reusable - Build App

on:
  workflow_call:
    inputs:
      docker_org:
        description: 'Docker organization name'
        required: true
        type: string
      docker_username_var:
        description: 'GitHub variable name for Docker username'
        required: false
        type: string
        default: 'DOCKER_USERNAME'
    secrets:
      REPOSITORY_TOKEN:
        required: false
      DOCKER_TOKEN:
        required: false
    outputs:
      project:
        description: 'Project name from superdeploy marker'
        value: ${{ jobs.build.outputs.project }}
      app:
        description: 'App name from superdeploy marker'
        value: ${{ jobs.build.outputs.app }}
      vm_role:
        description: 'VM role from superdeploy marker'
        value: ${{ jobs.build.outputs.vm_role }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      project: ${{ steps.config.outputs.project }}
      app: ${{ steps.config.outputs.app }}
      vm_role: ${{ steps.config.outputs.vm_role }}
      context: ${{ steps.config.outputs.context }}
      dockerfile: ${{ steps.config.outputs.dockerfile }}

    steps:
      - name: Download workspace artifact
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: Debug - Show artifact structure
        run: |
          echo "ðŸ“ Artifact structure after download:"
          ls -la
          echo ""
          echo "ðŸ“ Looking for superdeploy marker:"
          find . -name "superdeploy" -type f

      - name: Read app configuration
        id: config
        run: |
          # Find superdeploy marker file
          MARKER_FILE=$(find . -name "superdeploy" -type f | head -1)
          
          if [ -z "$MARKER_FILE" ]; then
            echo "âŒ ERROR: superdeploy marker file not found!"
            exit 1
          fi
          
          echo "ðŸ“ Found marker: $MARKER_FILE"
          
          PROJECT=$(grep "^project:" "$MARKER_FILE" | cut -d: -f2 | xargs)
          APP=$(grep "^app:" "$MARKER_FILE" | cut -d: -f2 | xargs)
          VM_ROLE=$(grep "^vm:" "$MARKER_FILE" | cut -d: -f2 | xargs)
          
          echo "project=$PROJECT" >> $GITHUB_OUTPUT
          echo "app=$APP" >> $GITHUB_OUTPUT
          echo "vm_role=$VM_ROLE" >> $GITHUB_OUTPUT
          
          # Determine build context and Dockerfile location
          if [ -d "$APP" ]; then
            # Multi-repo: app/ and commons/ directories exist
            BUILD_CONTEXT="."
            DOCKERFILE_PATH="./$APP/Dockerfile"
            echo "context=." >> $GITHUB_OUTPUT
            echo "dockerfile=$DOCKERFILE_PATH" >> $GITHUB_OUTPUT
            echo "âœ… Config: project=$PROJECT, app=$APP, vm=$VM_ROLE, context=. (multi-repo)"
          else
            # Single repo: files are in root (no app/ subdirectory)
            BUILD_CONTEXT="."
            DOCKERFILE_PATH="./Dockerfile"
            echo "context=." >> $GITHUB_OUTPUT
            echo "dockerfile=$DOCKERFILE_PATH" >> $GITHUB_OUTPUT
            echo "âœ… Config: project=$PROJECT, app=$APP, vm=$VM_ROLE, context=. (single repo)"
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars[inputs.docker_username_var] }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          # Context is always . (root) - contains either app files or app/ + commons/ dirs
          context: ${{ steps.config.outputs.context }}
          # Dockerfile path: ./Dockerfile for single repo, ./app/Dockerfile for multi-repo
          file: ${{ steps.config.outputs.dockerfile }}
          push: true
          tags: |
            ${{ inputs.docker_org }}/${{ steps.config.outputs.app }}:latest
            ${{ inputs.docker_org }}/${{ steps.config.outputs.app }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ inputs.docker_org }}/${{ steps.config.outputs.app }}:buildcache
          cache-to: type=registry,ref=${{ inputs.docker_org }}/${{ steps.config.outputs.app }}:buildcache,mode=max

