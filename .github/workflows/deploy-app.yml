# Reusable workflow for all SuperDeploy apps
# Usage: Call this from app repos
#
# Example:
#   jobs:
#     deploy:
#       uses: superdeploy/superdeploy/.github/workflows/deploy-app.yml@main
#       with:
#         additional_repos: 'cheapaio/commons'  # Optional
#       secrets: inherit

name: Deploy SuperDeploy App

on:
  workflow_call:
    inputs:
      additional_repos:
        description: 'Additional repos to checkout (comma-separated, e.g. "org/commons,org/shared")'
        required: false
        type: string
      app_path:
        description: 'Path where app is checked out (default: app name from marker)'
        required: false
        type: string
        default: ''
    secrets:
      REPOSITORY_TOKEN:
        required: true
      DOCKER_TOKEN:
        required: true

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      project: ${{ steps.config.outputs.project }}
      app: ${{ steps.config.outputs.app }}
      vm_role: ${{ steps.config.outputs.vm_role }}
      app_path: ${{ steps.config.outputs.app_path }}
    
    steps:
      - name: Checkout app repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.REPOSITORY_TOKEN }}
          path: ${{ inputs.app_path || github.event.repository.name }}
      
      # Parse marker file to get metadata
      - name: Read app configuration
        id: config
        run: |
          APP_PATH="${{ inputs.app_path }}"
          if [ -z "$APP_PATH" ]; then
            APP_PATH="${{ github.event.repository.name }}"
          fi
          
          cd "$APP_PATH"
          
          PROJECT=$(grep "^project:" superdeploy | cut -d: -f2 | xargs)
          APP=$(grep "^app:" superdeploy | cut -d: -f2 | xargs)
          VM_ROLE=$(grep "^vm:" superdeploy | cut -d: -f2 | xargs)
          
          echo "project=$PROJECT" >> $GITHUB_OUTPUT
          echo "app=$APP" >> $GITHUB_OUTPUT
          echo "vm_role=$VM_ROLE" >> $GITHUB_OUTPUT
          echo "app_path=$APP_PATH" >> $GITHUB_OUTPUT
      
      # Checkout additional repos if specified
      - name: Checkout additional repositories
        if: inputs.additional_repos != ''
        run: |
          IFS=',' read -ra REPOS <<< "${{ inputs.additional_repos }}"
          for REPO in "${REPOS[@]}"; do
            REPO=$(echo "$REPO" | xargs)  # Trim whitespace
            REPO_NAME=$(basename "$REPO")
            echo "ðŸ“¦ Checking out $REPO to $REPO_NAME..."
            
            git clone "https://oauth2:${{ secrets.REPOSITORY_TOKEN }}@github.com/$REPO.git" "$REPO_NAME"
          done
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./${{ steps.config.outputs.app_path }}/Dockerfile
          push: true
          tags: |
            ${{ vars.DOCKER_ORG }}/${{ steps.config.outputs.app }}:latest
            ${{ vars.DOCKER_ORG }}/${{ steps.config.outputs.app }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ vars.DOCKER_ORG }}/${{ steps.config.outputs.app }}:buildcache
          cache-to: type=registry,ref=${{ vars.DOCKER_ORG }}/${{ steps.config.outputs.app }}:buildcache,mode=max

  deploy:
    name: Deploy with zero-downtime
    needs: build
    environment: ${{ github.ref_name }}
    runs-on: 
      - self-hosted
      - superdeploy
      - ${{ needs.build.outputs.project }}
      - ${{ needs.build.outputs.vm_role }}
    
    steps:
      - name: Checkout app repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.REPOSITORY_TOKEN }}
          path: ${{ needs.build.outputs.app_path }}

      - name: Validate runner
        run: |
          echo "ðŸ” Validating deployment environment..."
          
          if [ ! -f /opt/superdeploy/.project ]; then
            echo "âŒ ERROR: /opt/superdeploy/.project not found!"
            exit 1
          fi
          
          RUNNER_PROJECT=$(cat /opt/superdeploy/.project)
          if [ "$RUNNER_PROJECT" != "${{ needs.build.outputs.project }}" ]; then
            echo "âŒ ERROR: Wrong project! Expected ${{ needs.build.outputs.project }}, got $RUNNER_PROJECT"
            exit 1
          fi
          
          echo "âœ… Correct VM for project: $RUNNER_PROJECT"
      
      - name: Create .env from GitHub Environment Secrets
        env:
          SECRETS_JSON: ${{ toJSON(secrets) }}
        run: |
          APP_NAME="${{ needs.build.outputs.app }}"
          PROJECT="${{ needs.build.outputs.project }}"
          ENV_DIR="/opt/superdeploy/projects/$PROJECT/data/$APP_NAME"
          
          echo "ðŸ“ Creating .env from GitHub secrets..."
          sudo mkdir -p "$ENV_DIR"
          
          # Get all secrets from GitHub and convert to .env format
          echo "$SECRETS_JSON" | jq -r 'to_entries[] | "\(.key)=\(.value)"' > /tmp/final.env
          
          sudo cp /tmp/final.env "$ENV_DIR/.env"
          sudo chown superdeploy:superdeploy "$ENV_DIR/.env"
          sudo chmod 600 "$ENV_DIR/.env"
          
          echo "âœ… Environment file created at $ENV_DIR/.env"
      
      - name: Update docker-compose.yml from marker file
        run: |
          APP_NAME="${{ needs.build.outputs.app }}"
          PROJECT="${{ needs.build.outputs.project }}"
          COMPOSE_FILE="/opt/superdeploy/projects/$PROJECT/compose/docker-compose.yml"
          MARKER_FILE="${GITHUB_WORKSPACE}/${{ needs.build.outputs.app_path }}/superdeploy"
          
          echo "ðŸ”„ Updating docker-compose.yml for $APP_NAME..."
          
          sudo python3 - "$APP_NAME" "$COMPOSE_FILE" "$MARKER_FILE" << 'PYSCRIPT'
          import yaml
          import sys
          
          app_name = sys.argv[1]
          compose_file = sys.argv[2]
          marker_file = sys.argv[3]
          
          try:
              with open(marker_file, 'r') as f:
                  marker = yaml.safe_load(f)
          
              with open(compose_file, 'r') as f:
                  compose = yaml.safe_load(f)
          
              project_name = marker.get('project', app_name)
          
              if compose.get('services') is None:
                  compose['services'] = {}
          
              processes = marker.get('processes', {})
              if not processes:
                  print(f"âš ï¸  WARNING: No processes found in marker file")
                  sys.exit(0)
          
              for process_name, process_config in processes.items():
                  service_name = f"{app_name}-{process_name}"
                  replicas = process_config.get('replicas', 1)
                  port = process_config.get('port')
                  command = process_config.get('command', '')
                  
                  if service_name not in compose['services']:
                      compose['services'][service_name] = {
                          'image': f"docker.io/${{ vars.DOCKER_ORG }}/{app_name}:latest",
                          'command': command,
                          'env_file': f"/opt/superdeploy/projects/{project_name}/data/{app_name}/.env",
                          'volumes': [
                              f"/opt/superdeploy/projects/{project_name}/data/{app_name}:/app/data",
                              f"/opt/superdeploy/projects/{project_name}/logs/{app_name}:/app/logs"
                          ],
                          'networks': {
                              f"{project_name}-network": {
                                  'aliases': [f"{app_name}-{process_name}"]
                              }
                          },
                          'deploy': {
                              'mode': 'replicated',
                              'replicas': replicas,
                              'update_config': {
                                  'parallelism': 1,
                                  'delay': '10s',
                                  'order': 'start-first',
                                  'failure_action': 'rollback'
                              },
                              'restart_policy': {
                                  'condition': 'on-failure',
                                  'delay': '5s',
                                  'max_attempts': 3
                              }
                          }
                      }
                      if port:
                          compose['services'][service_name]['ports'] = [f"{port}:{port}"]
                      print(f"âœ… Created {service_name}")
                  else:
                      service = compose['services'][service_name]
                      service['command'] = command
                      
                      if 'deploy' not in service:
                          service['deploy'] = {}
                      service['deploy']['replicas'] = replicas
                      
                      if port:
                          service.pop('ports', None)
                          service.pop('expose', None)
                          service['ports'] = [f"{port}:{port}"]
                      
                      network_alias = f"{app_name}-{process_name}"
                      network_name = f"{project_name}-network"
                      
                      if not isinstance(service.get('networks'), dict):
                          service['networks'] = {}
                      
                      if network_name not in service['networks'] or not isinstance(service['networks'].get(network_name), dict):
                          service['networks'][network_name] = {'aliases': []}
                      
                      if 'aliases' not in service['networks'][network_name]:
                          service['networks'][network_name]['aliases'] = []
                      if network_alias not in service['networks'][network_name]['aliases']:
                          service['networks'][network_name]['aliases'].append(network_alias)
                      
                      print(f"âœ… Updated {service_name}")
              
              with open(compose_file, 'w') as f:
                  yaml.dump(compose, f, default_flow_style=False, sort_keys=False)
              
          except Exception as e:
              import traceback
              print(f"âš ï¸  Failed to update compose: {e}")
              traceback.print_exc()
              sys.exit(0)
          PYSCRIPT
      
      - name: Deploy with zero-downtime (FIX: Kill containers properly)
        run: |
          cd /opt/superdeploy/projects/${{ needs.build.outputs.project }}/compose
          
          APP_NAME="${{ needs.build.outputs.app }}"
          DOCKER_IMAGE="${{ vars.DOCKER_ORG }}/${APP_NAME}:latest"
          
          # Get all process services for this app
          SERVICES=$(grep "^  ${APP_NAME}-" docker-compose.yml | cut -d: -f1 | xargs || true)
          
          if [ -z "$SERVICES" ]; then
            echo "âš ï¸  No services found for ${APP_NAME}"
            exit 0
          fi
          
          echo "ðŸ” Detected services: $SERVICES"
          echo "ðŸ“¦ Pulling new image..."
          docker pull "$DOCKER_IMAGE"
          
          echo "ðŸš€ Deploying services with zero-downtime..."
          
          for service in $SERVICES; do
            echo ""
            echo "â•â•â• Deploying $service â•â•â•"
            
            # FIX: Kill containers AND wait for ports to be released
            echo "  ðŸ§¹ Stopping old containers..."
            docker compose stop "$service" 2>/dev/null || true
            
            echo "  ðŸ—‘ï¸  Removing old containers..."
            docker compose rm -f "$service" 2>/dev/null || true
            
            # FIX: Wait for ports to be actually released by kernel
            echo "  â³ Waiting for ports to be released..."
            sleep 3
            
            # Start new containers
            echo "  ðŸš€ Starting new containers..."
            if ! docker compose up -d --no-deps "$service"; then
              echo "âŒ Failed to start $service"
              
              # Show logs
              docker compose logs "$service" --tail 50
              exit 1
            fi
            
            echo "  âœ… $service deployed"
          done
          
          # Health check
          echo ""
          echo "â³ Waiting for services to stabilize..."
          sleep 10
          
          echo ""
          echo "ðŸ“Š Service Status:"
          for service in $SERVICES; do
            RUNNING=$(docker compose ps "$service" --status running --format '{{.Name}}' 2>/dev/null | wc -l)
            EXPECTED=$(docker compose ps "$service" --format '{{.Name}}' 2>/dev/null | wc -l)
            
            if [ "$RUNNING" -eq "$EXPECTED" ] && [ "$RUNNING" -gt 0 ]; then
              echo "  âœ… $service: $RUNNING/$EXPECTED replicas running"
            else
              echo "  âŒ $service: $RUNNING/$EXPECTED replicas running"
            fi
          done
          
          # Cleanup old images
          docker image prune -f >/dev/null 2>&1 || true
          
          echo ""
          echo "âœ… Deployment completed!"
      
      - name: Update version tracking
        run: |
          PROJECT_DIR="/opt/superdeploy/projects/${{ needs.build.outputs.project }}"
          RELEASES_FILE="$PROJECT_DIR/releases.json"
          APP_NAME="${{ needs.build.outputs.app }}"
          
          sudo mkdir -p "$PROJECT_DIR"
          if [ ! -f "$RELEASES_FILE" ]; then
            echo "{}" | sudo tee "$RELEASES_FILE" > /dev/null
            sudo chown superdeploy:superdeploy "$RELEASES_FILE"
            sudo chmod 644 "$RELEASES_FILE"
          fi
          
          CURRENT_VERSION=$(sudo cat "$RELEASES_FILE" | jq -r --arg app "$APP_NAME" '.[$app][-1].version // "0.0.0"')
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          
          if echo "$COMMIT_MSG" | grep -qiE '^\[major\]|^breaking:'; then
            BUMP_TYPE="major"
          elif echo "$COMMIT_MSG" | grep -qiE '^\[minor\]|^feat:'; then
            BUMP_TYPE="minor"
          else
            BUMP_TYPE="patch"
          fi
          
          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"
          
          case $BUMP_TYPE in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac
          
          NEW_VERSION="$major.$minor.$patch"
          DEPLOYED_AT=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          NEW_RELEASE=$(jq -n \
            --arg ver "$NEW_VERSION" \
            --arg deployed "$DEPLOYED_AT" \
            --arg sha "${{ github.sha }}" \
            --arg actor "${{ github.actor }}" \
            --arg branch "${{ github.ref_name }}" \
            --arg commit "${{ github.event.head_commit.message }}" \
            '{
              version: $ver,
              deployed_at: $deployed,
              git_sha: $sha,
              deployed_by: $actor,
              branch: $branch,
              commit_message: $commit
            }')
          
          UPDATED_RELEASES=$(sudo cat "$RELEASES_FILE" | jq --argjson release "$NEW_RELEASE" --arg app "$APP_NAME" '
            .[$app] = ((.[$app] // []) + [$release])[-5:]
          ')
          
          echo "$UPDATED_RELEASES" | sudo tee "$RELEASES_FILE" > /dev/null
          sudo chown superdeploy:superdeploy "$RELEASES_FILE"
          sudo chmod 644 "$RELEASES_FILE"
          
          echo "âœ… Version tracked: v$NEW_VERSION"
      
      - name: Run deployment hooks
        run: |
          cd /opt/superdeploy/projects/${{ needs.build.outputs.project }}
          
          if [ ! -f config.yml ]; then
            echo "â­ï¸  No config.yml found, skipping hooks"
            exit 0
          fi
          
          APP_NAME="${{ needs.build.outputs.app }}"
          
          cat > /tmp/read_hooks.py <<'PYEOF'
          import yaml
          import sys
          import os
          
          try:
              with open('config.yml') as f:
                  config = yaml.safe_load(f)
              app_name = os.environ.get('APP_NAME', '')
              hooks = config.get('apps', {}).get(app_name, {}).get('hooks', {})
              after_deploy = hooks.get('after_deploy', [])
              if after_deploy:
                  for cmd in after_deploy:
                      print(cmd)
          except Exception:
              sys.exit(0)
          PYEOF
          
          HOOKS=$(APP_NAME="$APP_NAME" python3 /tmp/read_hooks.py)
          
          if [ -z "$HOOKS" ]; then
            echo "â­ï¸  No hooks configured"
            exit 0
          fi
          
          echo "ðŸ”§ Running post-deployment hooks..."
          cd compose
          
          HOOK_SERVICE=$(grep "^  ${APP_NAME}-\(web\|release\)" docker-compose.yml | head -1 | cut -d: -f1 | xargs || true)
          
          if [ -z "$HOOK_SERVICE" ]; then
            HOOK_SERVICE=$(grep "^  ${APP_NAME}-" docker-compose.yml | head -1 | cut -d: -f1 | xargs)
          fi
          
          echo "ðŸ“ Running hooks on: $HOOK_SERVICE"
          
          FAILED=0
          echo "$HOOKS" | while IFS= read -r cmd; do
            if [ -n "$cmd" ]; then
              echo "â–¶ Running: $cmd"
              if ! docker compose exec -T $HOOK_SERVICE $cmd; then
                echo "âš ï¸  Hook failed: $cmd"
                FAILED=1
              fi
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo "âŒ Hooks failed"
            exit 1
          fi
          
          echo "âœ… Hooks completed"

