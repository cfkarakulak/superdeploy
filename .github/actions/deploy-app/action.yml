name: 'Deploy Application'
description: 'Deploys app to self-hosted runner with zero-downtime'

inputs:
  project:
    description: 'Project name'
    required: true
  app:
    description: 'App name'
    required: true
  app_path:
    description: 'Path to app directory'
    required: true
  docker_image:
    description: 'Docker image to deploy'
    required: true
  secrets_json:
    description: 'JSON of all secrets'
    required: true

runs:
  using: composite
  steps:
    - name: Validate runner
      shell: bash
      run: |
        echo "ðŸ” Validating deployment environment..."
        
        if [ ! -f /opt/superdeploy/.project ]; then
          echo "âŒ ERROR: /opt/superdeploy/.project not found!"
          exit 1
        fi
        
        RUNNER_PROJECT=$(cat /opt/superdeploy/.project)
        if [ "$RUNNER_PROJECT" != "${{ inputs.project }}" ]; then
          echo "âŒ ERROR: Wrong project! Expected ${{ inputs.project }}, got $RUNNER_PROJECT"
          exit 1
        fi
        
        echo "âœ… Correct VM for project: $RUNNER_PROJECT"
    
    - name: Create .env from secrets
      shell: bash
      run: |
        ENV_DIR="/opt/superdeploy/projects/${{ inputs.project }}/data/${{ inputs.app }}"
        
        echo "ðŸ“ Creating .env from GitHub secrets..."
        sudo mkdir -p "$ENV_DIR"
        
        echo '${{ inputs.secrets_json }}' | jq -r 'to_entries[] | "\(.key)=\(.value)"' > /tmp/final.env
        
        sudo cp /tmp/final.env "$ENV_DIR/.env"
        sudo chown superdeploy:superdeploy "$ENV_DIR/.env"
        sudo chmod 600 "$ENV_DIR/.env"
        
        echo "âœ… Environment file created"
    
    - name: Update docker-compose.yml
      shell: bash
      run: |
        COMPOSE_FILE="/opt/superdeploy/projects/${{ inputs.project }}/compose/docker-compose.yml"
        MARKER_FILE="${GITHUB_WORKSPACE}/${{ inputs.app_path }}/superdeploy"
        
        echo "ðŸ”„ Updating docker-compose.yml..."
        
        sudo python3 - "${{ inputs.app }}" "$COMPOSE_FILE" "$MARKER_FILE" "${{ inputs.docker_image }}" << 'PYSCRIPT'
        import yaml, sys
        
        app_name, compose_file, marker_file, docker_image = sys.argv[1:5]
        
        try:
            with open(marker_file) as f:
                marker = yaml.safe_load(f)
            with open(compose_file) as f:
                compose = yaml.safe_load(f)
            
            project_name = marker.get('project', app_name)
            
            if compose.get('services') is None:
                compose['services'] = {}
            
            processes = marker.get('processes', {})
            if not processes:
                print(f"âš ï¸  No processes found")
                sys.exit(0)
            
            for process_name, process_config in processes.items():
                service_name = f"{app_name}-{process_name}"
                replicas = process_config.get('replicas', 1)
                port = process_config.get('port')
                command = process_config.get('command', '')
                
                service = {
                    'image': docker_image,
                    'command': command,
                    'env_file': f"/opt/superdeploy/projects/{project_name}/data/{app_name}/.env",
                    'volumes': [
                        f"/opt/superdeploy/projects/{project_name}/data/{app_name}:/app/data",
                        f"/opt/superdeploy/projects/{project_name}/logs/{app_name}:/app/logs"
                    ],
                    'networks': {
                        f"{project_name}-network": {'aliases': [f"{app_name}-{process_name}"]}
                    },
                    'deploy': {
                        'mode': 'replicated',
                        'replicas': replicas,
                        'update_config': {
                            'parallelism': 1,
                            'delay': '10s',
                            'order': 'start-first',
                            'failure_action': 'rollback'
                        },
                        'restart_policy': {
                            'condition': 'on-failure',
                            'delay': '5s',
                            'max_attempts': 3
                        }
                    }
                }
                
                if port:
                    service['ports'] = [f"{port}:{port}"]
                
                compose['services'][service_name] = service
                print(f"âœ… {service_name}")
            
            with open(compose_file, 'w') as f:
                yaml.dump(compose, f, default_flow_style=False, sort_keys=False)
        
        except Exception as e:
            import traceback
            print(f"âš ï¸  Failed: {e}")
            traceback.print_exc()
            sys.exit(0)
        PYSCRIPT
    
    - name: Deploy with zero-downtime
      shell: bash
      run: |
        cd /opt/superdeploy/projects/${{ inputs.project }}/compose
        
        APP_NAME="${{ inputs.app }}"
        DOCKER_IMAGE="${{ inputs.docker_image }}"
        
        SERVICES=$(grep "^  ${APP_NAME}-" docker-compose.yml | cut -d: -f1 | xargs || true)
        
        if [ -z "$SERVICES" ]; then
          echo "âš ï¸  No services found"
          exit 0
        fi
        
        echo "ðŸ” Services: $SERVICES"
        echo "ðŸ“¦ Pulling image..."
        docker pull "$DOCKER_IMAGE"
        
        for service in $SERVICES; do
          echo ""
          echo "â•â•â• $service â•â•â•"
          
          # FIX: Force kill containers and wait for ports
          echo "  ðŸ§¹ Stopping..."
          docker compose stop "$service" 2>/dev/null || true
          
          echo "  ðŸ—‘ï¸  Removing..."
          docker compose rm -f "$service" 2>/dev/null || true
          
          # FIX: Wait for ports to be released by kernel
          echo "  â³ Waiting for ports..."
          sleep 3
          
          echo "  ðŸš€ Starting..."
          if ! docker compose up -d --no-deps "$service"; then
            echo "âŒ Failed to start $service"
            docker compose logs "$service" --tail 50
            exit 1
          fi
          
          echo "  âœ… Deployed"
        done
        
        echo ""
        echo "â³ Stabilizing..."
        sleep 10
        
        echo ""
        echo "ðŸ“Š Status:"
        for service in $SERVICES; do
          RUNNING=$(docker compose ps "$service" --status running --format '{{.Name}}' 2>/dev/null | wc -l)
          EXPECTED=$(docker compose ps "$service" --format '{{.Name}}' 2>/dev/null | wc -l)
          
          if [ "$RUNNING" -eq "$EXPECTED" ] && [ "$RUNNING" -gt 0 ]; then
            echo "  âœ… $service: $RUNNING/$EXPECTED"
          else
            echo "  âŒ $service: $RUNNING/$EXPECTED"
          fi
        done
        
        docker image prune -f >/dev/null 2>&1 || true
        
        echo ""
        echo "âœ… Deployment completed!"

