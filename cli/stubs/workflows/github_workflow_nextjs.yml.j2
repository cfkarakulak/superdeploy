name: Deploy to {{ project }}

on:
  push:
    branches: [production, staging]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
{% raw %}      project: ${{ steps.config.outputs.project }}
      app: ${{ steps.config.outputs.app }}
      vm_role: ${{ steps.config.outputs.vm_role }}
{% endraw %}    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: {% raw %}${{ secrets.GITHUB_TOKEN }}{% endraw %}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Read app configuration
        id: config
        run: |
          PROJECT=$(grep "^project:" superdeploy | cut -d: -f2 | xargs)
          APP=$(grep "^app:" superdeploy | cut -d: -f2 | xargs)
          VM_ROLE=$(grep "^vm:" superdeploy | cut -d: -f2 | xargs)
{% raw %}          echo "project=$PROJECT" >> $GITHUB_OUTPUT
          echo "app=$APP" >> $GITHUB_OUTPUT
          echo "vm_role=$VM_ROLE" >> $GITHUB_OUTPUT
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKER_ORG }}/${{ steps.config.outputs.app }}:latest
            ${{ secrets.DOCKER_ORG }}/${{ steps.config.outputs.app }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ secrets.DOCKER_ORG }}/${{ steps.config.outputs.app }}:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_ORG }}/${{ steps.config.outputs.app }}:buildcache,mode=max

  deploy:
    needs: build
    environment: ${{ github.ref_name }}
    runs-on: 
      - self-hosted
      - superdeploy
      - ${{ needs.build.outputs.project }}
      - ${{ needs.build.outputs.vm_role }}
    
    steps:
      - name: Validate runner
        run: |
          echo "üîç Validating deployment environment..."
          
          if [ ! -f /opt/superdeploy/.project ]; then
            echo "‚ùå ERROR: /opt/superdeploy/.project not found!"
            exit 1
          fi
          
          RUNNER_PROJECT=$(cat /opt/superdeploy/.project)
          if [ "$RUNNER_PROJECT" != "${{ needs.build.outputs.project }}" ]; then
            echo "‚ùå ERROR: Wrong project! Expected ${{ needs.build.outputs.project }}, got $RUNNER_PROJECT"
            exit 1
          fi
          
          echo "‚úÖ Correct VM for project: $RUNNER_PROJECT"
      
      - name: Create .env from GitHub Environment Secrets
        run: |
          APP_NAME="${{ needs.build.outputs.app }}"
          PROJECT="${{ needs.build.outputs.project }}"
          ENV_DIR="/opt/superdeploy/projects/$PROJECT/data/$APP_NAME"
          
          echo "üìù Creating .env from GitHub secrets..."
          sudo mkdir -p "$ENV_DIR"
          
          # Get all secrets from GitHub and convert to .env format
          cat <<'SECRETS_EOF' | jq -r 'to_entries[] | "\(.key)=\(.value)"' > /tmp/final.env
${{ toJSON(secrets) }}
SECRETS_EOF
          
          sudo cp /tmp/final.env "$ENV_DIR/.env"
          sudo chown superdeploy:superdeploy "$ENV_DIR/.env"
          sudo chmod 600 "$ENV_DIR/.env"
          
          echo "‚úÖ Environment file created at $ENV_DIR/.env"
          echo "üìä Total variables: $(wc -l < "$ENV_DIR/.env")"
      
      - name: Deploy application (zero-downtime with replicas)
        run: |
          cd /opt/superdeploy/projects/${{ needs.build.outputs.project }}/compose
          
          APP_NAME="${{ needs.build.outputs.app }}"
          
          # Check if any process services exist for this app (pattern: app-*)
          if ! grep -q "^  ${APP_NAME}-" docker-compose.yml; then
            echo "‚è≠Ô∏è  Skipping: App not configured on this VM"
            exit 0
          fi
          
          # Create empty .env files for other apps to prevent docker-compose errors
          for app_dir in ../data/*/; do
            if [ -d "$app_dir" ]; then
              app_name=$(basename "$app_dir")
              env_file="../data/$app_name/.env"
              if [ ! -f "$env_file" ]; then
                echo "# Placeholder .env for $app_name" > "$env_file"
                echo "üìù Created placeholder .env for $app_name"
              fi
            fi
          done
          
          # Get all process services for this app
          SERVICES=$(grep "^  ${APP_NAME}-" docker-compose.yml | cut -d: -f1 | xargs)
          echo "üîç Detected services: $SERVICES"
          
          echo "üöÄ Starting zero-downtime deployment with replicas..."
          
          # Pull new image first (same image for all processes)
          echo "üì¶ Step 1/3: Pulling new image..."
          docker pull ${{ secrets.DOCKER_ORG }}/${APP_NAME}:latest
          
          # Deploy all process services with Docker Compose rolling update
          echo "üöÄ Step 2/3: Deploying all processes (rolling update)..."
          # Docker Compose automatically:
          # - Starts new replicas first (order: start-first)
          # - Waits for health checks
          # - Stops old replicas gracefully
          # - Automatic rollback on failure
          for service in $SERVICES; do
            echo "  Deploying $service..."
            docker compose up -d --no-deps $service
          done
          
          # Wait for deployment to stabilize
          echo "‚è≥ Step 3/3: Health check (waiting for all replicas)..."
          sleep 10
          
          # Check status for all process services
          TOTAL_RUNNING=0
          TOTAL_EXPECTED=0
          for service in $SERVICES; do
            RUNNING=$(docker compose ps $service --status running --format '{{.Name}}' 2>/dev/null | wc -l)
            EXPECTED=$(docker compose ps $service --format '{{.Name}}' 2>/dev/null | wc -l)
            TOTAL_RUNNING=$((TOTAL_RUNNING + RUNNING))
            TOTAL_EXPECTED=$((TOTAL_EXPECTED + EXPECTED))
            echo "  $service: $RUNNING/$EXPECTED replicas running"
          done
          
          if [ "$TOTAL_RUNNING" -ge "1" ]; then
            echo "‚úÖ Deployment successful! ($TOTAL_RUNNING/$TOTAL_EXPECTED total replicas running)"
            
            # Show logs from first service
            FIRST_SERVICE=$(echo $SERVICES | awk '{print $1}')
            FIRST_CONTAINER=$(docker compose ps $FIRST_SERVICE --format '{{.Name}}' 2>/dev/null | head -1)
            if [ -n "$FIRST_CONTAINER" ]; then
              echo ""
              echo "üìã Recent logs from $FIRST_CONTAINER:"
              docker logs $FIRST_CONTAINER --tail 20 2>/dev/null || true
            fi
          else
            echo "‚ùå Deployment failed - no replicas running"
            echo ""
            echo "üìã Service logs:"
            for service in $SERVICES; do
              echo "=== $service ==="
              docker compose logs $service --tail 20
            done
            exit 1
          fi
          
          # Cleanup old images
          docker image prune -f >/dev/null 2>&1 || true
      
      - name: Calculate and update version
        run: |
          PROJECT_DIR="/opt/superdeploy/projects/${{ needs.build.outputs.project }}"
          VERSION_FILE="$PROJECT_DIR/versions.json"
          APP_NAME="${{ needs.build.outputs.app }}"
          
          # Initialize versions.json if it doesn't exist
          sudo mkdir -p "$PROJECT_DIR"
          if [ ! -f "$VERSION_FILE" ]; then
            echo "{}" | sudo tee "$VERSION_FILE" > /dev/null
            sudo chown superdeploy:superdeploy "$VERSION_FILE"
            sudo chmod 644 "$VERSION_FILE"
          fi
          
          # Get current version for this app
          CURRENT_VERSION=$(sudo cat "$VERSION_FILE" | jq -r --arg app "$APP_NAME" '.[$app].version // "0.0.0"')
          echo "Current version: $CURRENT_VERSION"
          
          # Determine version bump type from commit message
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          
          if echo "$COMMIT_MSG" | grep -qiE '^\[major\]|^breaking:'; then
            BUMP_TYPE="major"
          elif echo "$COMMIT_MSG" | grep -qiE '^\[minor\]|^feat:'; then
            BUMP_TYPE="minor"
          else
            BUMP_TYPE="patch"
          fi
          
          echo "Bump type: $BUMP_TYPE"
          
          # Parse and increment version
          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"
          
          case $BUMP_TYPE in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac
          
          NEW_VERSION="$major.$minor.$patch"
          DEPLOYED_AT=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo "New version: $NEW_VERSION"
          echo "üìå Updating version: $APP_NAME v$NEW_VERSION"
          
          # Update version for this app
          UPDATED_JSON=$(sudo cat "$VERSION_FILE" | jq --arg app "$APP_NAME" --arg ver "$NEW_VERSION" --arg deployed "$DEPLOYED_AT" --arg sha "${{ github.sha }}" --arg actor "${{ github.actor }}" --arg branch "${{ github.ref_name }}" '
            .[$app] = {
              "version": $ver,
              "deployed_at": $deployed,
              "git_sha": $sha,
              "deployed_by": $actor,
              "branch": $branch
            }
          ')
          
          echo "$UPDATED_JSON" | sudo tee "$VERSION_FILE" > /dev/null
          sudo chown superdeploy:superdeploy "$VERSION_FILE"
          sudo chmod 644 "$VERSION_FILE"
          
          echo "‚úÖ Version tracked: v$NEW_VERSION"
      
      - name: Run deployment hooks
        run: |
          # Post-deployment hooks run after successful deployment
          # Configure in projects/{{ project }}/config.yml:
          #
          # apps:
          #   {{ app }}:
          #     hooks:
          #       after_deploy:
          #         - npx prisma migrate deploy         # Run Prisma migrations
          #         - npm run db:seed                   # Seed database (optional)
          #         - npm run cache:clear               # Clear Next.js cache
          #
          # Hooks run inside the container using docker compose exec
          # If any hook fails, deployment is marked as failed
          
          cd /opt/superdeploy/projects/${{ needs.build.outputs.project }}
          
          if [ ! -f config.yml ]; then
            echo "‚è≠Ô∏è  No config.yml found, skipping hooks"
            exit 0
          fi
          
          APP_NAME="${{ needs.build.outputs.app }}"
          
          cat > /tmp/read_hooks.py <<'PYEOF'
          import yaml
          import sys
          import os
          
          try:
              with open('config.yml') as f:
                  config = yaml.safe_load(f)
              app_name = os.environ.get('APP_NAME', '')
              hooks = config.get('apps', {}).get(app_name, {}).get('hooks', {})
              after_deploy = hooks.get('after_deploy', [])
              if after_deploy:
                  for cmd in after_deploy:
                      print(cmd)
          except Exception:
              sys.exit(0)
          PYEOF
          
          HOOKS=$(APP_NAME="$APP_NAME" python3 /tmp/read_hooks.py)
          
          if [ -z "$HOOKS" ]; then
            echo "‚è≠Ô∏è  No post-deployment hooks configured for ${{ needs.build.outputs.app }}"
            exit 0
          fi
          
          echo "üîß Running post-deployment hooks for ${{ needs.build.outputs.app }}..."
          cd compose
          
          # Find first web or release process service for running hooks
          # Hooks should run only once (migrations, cache clear, etc.)
          HOOK_SERVICE=$(grep "^  ${APP_NAME}-\(web\|release\)" docker-compose.yml | head -1 | cut -d: -f1 | xargs)
          
          if [ -z "$HOOK_SERVICE" ]; then
            # Fallback: use first available service
            HOOK_SERVICE=$(grep "^  ${APP_NAME}-" docker-compose.yml | head -1 | cut -d: -f1 | xargs)
          fi
          
          echo "üìç Running hooks on service: $HOOK_SERVICE"
          
          FAILED=0
          echo "$HOOKS" | while IFS= read -r cmd; do
            if [ -n "$cmd" ]; then
              echo "‚ñ∂ Running: $cmd"
              # Note: docker compose exec automatically chooses first replica
              if ! docker compose exec -T $HOOK_SERVICE $cmd; then
                echo "‚ö†Ô∏è  Hook failed: $cmd"
                FAILED=1
              fi
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo "‚ùå Post-deployment hooks failed"
            exit 1
          fi
          
          echo "‚úÖ Post-deployment hooks completed"
{% endraw %}

