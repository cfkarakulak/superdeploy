name: Deploy to {{ project }}

on:
  push:
    branches: [production, staging]
  workflow_dispatch:

jobs:
  # üéØ PREPARE: Checkout repository
  prepare:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout {{ app_name }} repository
        uses: actions/checkout@v4
        with:
          token: {% raw %}${{ secrets.REPOSITORY_TOKEN }}{% endraw %}
          path: {{ app_name }}

      - name: Upload workspace as artifact
        uses: actions/upload-artifact@v4
        with:
          name: workspace
          path: {{ app_name }}
          retention-days: 1

  # üì¶ BUILD: Inline build with environment secrets for NEXT_PUBLIC_* vars
  # This MUST be inline because Next.js embeds NEXT_PUBLIC_* at build time
  build:
    needs: prepare
    environment: {% raw %}${{ github.ref_name }}{% endraw %}
    runs-on: ubuntu-latest
    steps:
      - name: Download workspace artifact
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .

      - name: Read app configuration
        id: config
        run: |
          MARKER_FILE=$(find . -name "superdeploy" -type f | head -1)
          if [ -z "$MARKER_FILE" ]; then
            echo "‚ùå ERROR: superdeploy marker file not found!"
            exit 1
          fi

          PROJECT=$(grep "^project:" "$MARKER_FILE" | cut -d: -f2 | xargs)
          APP=$(grep "^app:" "$MARKER_FILE" | cut -d: -f2 | xargs)
          VM_ROLE=$(grep "^vm:" "$MARKER_FILE" | cut -d: -f2 | xargs)

          echo "project=$PROJECT" >> {% raw %}$GITHUB_OUTPUT{% endraw %}
          echo "app=$APP" >> {% raw %}$GITHUB_OUTPUT{% endraw %}
          echo "vm_role=$VM_ROLE" >> {% raw %}$GITHUB_OUTPUT{% endraw %}
          echo "‚úÖ Config: project=$PROJECT, app=$APP, vm=$VM_ROLE"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: {% raw %}${{ vars.DOCKER_USERNAME }}{% endraw %}
          password: {% raw %}${{ secrets.DOCKER_TOKEN }}{% endraw %}

      - name: Build and push Docker image with build-args
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            {% raw %}${{ vars.DOCKER_ORG }}{% endraw %}/{% raw %}${{ steps.config.outputs.app }}{% endraw %}:latest
            {% raw %}${{ vars.DOCKER_ORG }}{% endraw %}/{% raw %}${{ steps.config.outputs.app }}{% endraw %}:{% raw %}${{ github.sha }}{% endraw %}
          cache-from: type=registry,ref={% raw %}${{ vars.DOCKER_ORG }}{% endraw %}/{% raw %}${{ steps.config.outputs.app }}{% endraw %}:buildcache
          cache-to: type=registry,ref={% raw %}${{ vars.DOCKER_ORG }}{% endraw %}/{% raw %}${{ steps.config.outputs.app }}{% endraw %}:buildcache,mode=max
          build-args: |
            AUTH_SECRET={% raw %}${{ secrets.AUTH_SECRET }}{% endraw %}
            NEXT_PUBLIC_API_URL={% raw %}${{ secrets.NEXT_PUBLIC_API_URL }}{% endraw %}
            NEXT_PUBLIC_WS_URL={% raw %}${{ secrets.NEXT_PUBLIC_WS_URL }}{% endraw %}

  # üöÄ DEPLOY: Inline deployment with environment secrets access
  deploy:
    needs: build
    environment: {% raw %}${{ github.ref_name }}{% endraw %}
    # ‚ö†Ô∏è  IMPORTANT: runs-on labels should be hardcoded for your app
    # GitHub Actions does not support dynamic runs-on evaluation
    # Update these labels to match your deployment target
    runs-on:
      - self-hosted
      - superdeploy
      - {{ project }}  # ‚Üê Update if needed
      - app           # ‚Üê Update to your VM role (app/core/worker)

    steps:
      - name: Download workspace artifact
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: {% raw %}${{ github.workspace }}{% endraw %}

      - name: Read app configuration from marker
        id: config
        run: |
          MARKER_FILE=$(find "{% raw %}$GITHUB_WORKSPACE{% endraw %}" -name "superdeploy" -type f | head -1)
          if [ ! -f "$MARKER_FILE" ]; then
            echo "‚ùå ERROR: Marker file not found!"
            exit 1
          fi

          PROJECT=$(grep "^project:" "$MARKER_FILE" | cut -d: -f2 | xargs)
          APP=$(grep "^app:" "$MARKER_FILE" | cut -d: -f2 | xargs)

          echo "project=$PROJECT" >> {% raw %}$GITHUB_OUTPUT{% endraw %}
          echo "app=$APP" >> {% raw %}$GITHUB_OUTPUT{% endraw %}
          echo "‚úÖ Config: project=$PROJECT, app=$APP"

      - name: Validate runner
        run: |
          RUNNER_PROJECT=$(cat /opt/superdeploy/.project)
          if [ "$RUNNER_PROJECT" != "{% raw %}${{ steps.config.outputs.project }}{% endraw %}" ]; then
            echo "‚ùå ERROR: Wrong project! Expected {% raw %}${{ steps.config.outputs.project }}{% endraw %}, got $RUNNER_PROJECT"
            exit 1
          fi
          echo "‚úÖ Correct VM for project: $RUNNER_PROJECT"

      - name: Create .env from GitHub Environment Secrets
        env:
          SECRETS_JSON: {% raw %}${{ toJSON(secrets) }}{% endraw %}
        run: |
          APP_NAME="{% raw %}${{ steps.config.outputs.app }}{% endraw %}"
          PROJECT="{% raw %}${{ steps.config.outputs.project }}{% endraw %}"
          ENV_DIR="/opt/superdeploy/projects/$PROJECT/data/$APP_NAME"

          echo "üìù Creating .env from GitHub secrets..."
          sudo mkdir -p "$ENV_DIR"

          echo "$SECRETS_JSON" | jq -r 'to_entries[] | "\(.key)=\(.value)"' > /tmp/final.env

          sudo cp /tmp/final.env "$ENV_DIR/.env"
          sudo chown superdeploy:superdeploy "$ENV_DIR/.env"
          sudo chmod 600 "$ENV_DIR/.env"

          echo "‚úÖ Environment file created"
          echo "üìä Total variables: $(wc -l < "$ENV_DIR/.env")"

      - name: Update docker-compose.yml from marker file
        run: |
          PROJECT_NAME="{% raw %}${{ steps.config.outputs.project }}{% endraw %}"
          APP_NAME="{% raw %}${{ steps.config.outputs.app }}{% endraw %}"
          COMPOSE_DIR="/opt/superdeploy/projects/${PROJECT_NAME}/compose"
          MARKER_FILE="{% raw %}${{ github.workspace }}{% endraw %}/superdeploy"

          cd "$COMPOSE_DIR"

          if [ ! -f "$MARKER_FILE" ]; then
            echo "‚ö†Ô∏è  No superdeploy marker file found"
            exit 0
          fi

          sudo python3 - "$APP_NAME" "docker-compose.yml" "$MARKER_FILE" << 'PYSCRIPT'
          import sys
          import yaml
          import os

          app_name = sys.argv[1]
          compose_file = sys.argv[2]
          marker_file = sys.argv[3]
          project_name = os.environ.get('PROJECT_NAME', 'project')

          try:
              # Load marker file
              with open(marker_file, 'r') as f:
                  marker = yaml.safe_load(f)

              # Load compose file
              with open(compose_file, 'r') as f:
                  compose = yaml.safe_load(f)

              if not compose or 'services' not in compose:
                  compose = {'services': {}, 'networks': {f'{project_name}-network': {'external': True}}}

              # Get processes from marker
              processes = marker.get('processes', {})

              for process_name, process_config in processes.items():
                  service_name = f"{app_name}-{process_name}"
                  command = process_config.get('command', '')
                  replicas = process_config.get('replicas', 1)
                  port = process_config.get('port')

                  if service_name in compose['services']:
                      # UPDATE EXISTING SERVICE
                      service = compose['services'][service_name]
                      service['command'] = command

                      if 'deploy' not in service:
                          service['deploy'] = {}
                      service['deploy']['replicas'] = replicas

                      # Update healthcheck based on process type
                      if port:
                          # Web process: HTTP healthcheck (without -f to tolerate 404/500)
                          service['healthcheck'] = {
                              'test': ['CMD', 'curl', f'http://localhost:{port}/health'],
                              'interval': '30s',
                              'timeout': '10s',
                              'retries': 3,
                              'start_period': '40s'
                          }
                          service.pop('expose', None)
                          service['ports'] = [f"{port}:{port}"]
                      else:
                          # Worker process: Disable healthcheck
                          service['healthcheck'] = {'disable': True}

                      print(f"‚úÖ Updated {service_name}: replicas={replicas}, port={port}")
                  else:
                      # CREATE NEW SERVICE
                      compose['services'][service_name] = {
                          'image': f"docker.io/{{ docker_org }}/{app_name}:latest",
                          'command': command,
                          'env_file': f"/opt/superdeploy/projects/{project_name}/data/{app_name}/.env",
                          'volumes': [
                              f"/opt/superdeploy/projects/{project_name}/data/{app_name}:/app/data",
                              f"/opt/superdeploy/projects/{project_name}/logs/{app_name}:/app/logs"
                          ],
                          'networks': {
                              f"{project_name}-network": {
                                  'aliases': [f"{app_name}-{process_name}"]
                              }
                          },
                          'deploy': {
                              'mode': 'replicated',
                              'replicas': replicas,
                              'update_config': {
                                  'parallelism': 1,
                                  'delay': '10s',
                                  'order': 'start-first',
                                  'failure_action': 'rollback'
                              },
                              'restart_policy': {
                                  'condition': 'on-failure',
                                  'delay': '5s',
                                  'max_attempts': 3
                              }
                          }
                      }

                      # Add healthcheck based on process type
                      if port:
                          compose['services'][service_name]['healthcheck'] = {
                              'test': ['CMD', 'curl', f'http://localhost:{port}/health'],
                              'interval': '30s',
                              'timeout': '10s',
                              'retries': 3,
                              'start_period': '40s'
                          }
                          compose['services'][service_name]['ports'] = [f"{port}:{port}"]
                      else:
                          compose['services'][service_name]['healthcheck'] = {'disable': True}

                      print(f"‚úÖ Created {service_name}: replicas={replicas}, port={port}, command={command}")

              with open(compose_file, 'w') as f:
                  yaml.dump(compose, f, default_flow_style=False, sort_keys=False)

              print(f"‚úÖ docker-compose.yml updated for {app_name}")

          except Exception as e:
              import traceback
              print(f"‚ö†Ô∏è  Failed to update compose: {e}")
              traceback.print_exc()
              print(f"‚ö†Ô∏è  Will use existing compose file")
              sys.exit(0)
          PYSCRIPT

      - name: Deploy application (zero-downtime)
        run: |
          cd /opt/superdeploy/projects/{% raw %}${{ steps.config.outputs.project }}{% endraw %}/compose

          APP_NAME="{% raw %}${{ steps.config.outputs.app }}{% endraw %}"

          if ! grep -q "^  ${APP_NAME}-" docker-compose.yml; then
            echo "‚è≠Ô∏è  Skipping: App not configured on this VM"
            exit 0
          fi

          # Create placeholder .env files for other apps
          for app_dir in ../data/*/; do
            if [ -d "$app_dir" ]; then
              app_name=$(basename "$app_dir")
              env_file="../data/$app_name/.env"
              if [ ! -f "$env_file" ]; then
                echo "# Placeholder .env for $app_name" > "$env_file"
              fi
            fi
          done

          SERVICES=$(grep "^  ${APP_NAME}-" docker-compose.yml | cut -d: -f1 | xargs)
          echo "üîç Detected services: $SERVICES"

          echo "üöÄ Starting zero-downtime deployment..."

          # Pull new image
          echo "üì¶ Step 1/3: Pulling new image..."
          docker pull {% raw %}${{ vars.DOCKER_ORG }}{% endraw %}/${APP_NAME}:latest

          # Deploy all process services
          echo "üöÄ Step 2/3: Deploying all processes..."
          for service in $SERVICES; do
            echo "  Deploying $service..."
            docker compose up -d --no-deps $service
          done

          # Wait and check health
          echo "‚è≥ Step 3/3: Health check..."
          sleep 10

          TOTAL_RUNNING=0
          for service in $SERVICES; do
            RUNNING=$(docker compose ps $service --status running --format '{% raw %}{{.Name}}{% endraw %}' 2>/dev/null | wc -l)
            TOTAL_RUNNING=$((TOTAL_RUNNING + RUNNING))
            echo "  $service: $RUNNING replicas running"
          done

          if [ "$TOTAL_RUNNING" -ge "1" ]; then
            echo "‚úÖ Deployment successful! ($TOTAL_RUNNING replicas running)"
          else
            echo "‚ùå Deployment failed - no replicas running"
            for service in $SERVICES; do
              echo "=== $service ==="
              docker compose logs $service --tail 20
            done
            exit 1
          fi

          docker image prune -f >/dev/null 2>&1 || true

      - name: Calculate and update version
        run: |
          PROJECT_DIR="/opt/superdeploy/projects/{% raw %}${{ steps.config.outputs.project }}{% endraw %}"
          RELEASES_FILE="$PROJECT_DIR/releases.json"
          APP_NAME="{% raw %}${{ steps.config.outputs.app }}{% endraw %}"

          sudo mkdir -p "$PROJECT_DIR"
          if [ ! -f "$RELEASES_FILE" ]; then
            echo "{}" | sudo tee "$RELEASES_FILE" > /dev/null
            sudo chown superdeploy:superdeploy "$RELEASES_FILE"
            sudo chmod 644 "$RELEASES_FILE"
          fi

          CURRENT_VERSION=$(sudo cat "$RELEASES_FILE" | jq -r --arg app "$APP_NAME" '.[$app][-1].version // "0.0.0"')
          echo "Current version: $CURRENT_VERSION"

          COMMIT_MSG="{% raw %}${{ github.event.head_commit.message }}{% endraw %}"

          if echo "$COMMIT_MSG" | grep -qiE '^\[major\]|^breaking:'; then
            BUMP_TYPE="major"
          elif echo "$COMMIT_MSG" | grep -qiE '^\[minor\]|^feat:'; then
            BUMP_TYPE="minor"
          else
            BUMP_TYPE="patch"
          fi

          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"

          case $BUMP_TYPE in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac

          NEW_VERSION="$major.$minor.$patch"
          DEPLOYED_AT=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          echo "New version: $NEW_VERSION"

          NEW_RELEASE=$(jq -n --arg ver "$NEW_VERSION" --arg deployed "$DEPLOYED_AT" --arg sha "{% raw %}${{ github.sha }}{% endraw %}" --arg actor "{% raw %}${{ github.actor }}{% endraw %}" --arg branch "{% raw %}${{ github.ref_name }}{% endraw %}" --arg commit "{% raw %}${{ github.event.head_commit.message }}{% endraw %}" '{
            version: $ver,
            deployed_at: $deployed,
            git_sha: $sha,
            deployed_by: $actor,
            branch: $branch,
            commit_message: $commit
          }')

          UPDATED_RELEASES=$(sudo cat "$RELEASES_FILE" | jq --argjson release "$NEW_RELEASE" --arg app "$APP_NAME" '
            .[$app] = ((.[$app] // []) + [$release])[-5:]
          ')

          echo "$UPDATED_RELEASES" | sudo tee "$RELEASES_FILE" > /dev/null
          sudo chown superdeploy:superdeploy "$RELEASES_FILE"
          sudo chmod 644 "$RELEASES_FILE"

          echo "‚úÖ Version tracked: v$NEW_VERSION"

      - name: Run post-deployment hooks from marker file
        run: |
          # ‚ö†Ô∏è  HOOKS RUN FROM MARKER FILE (superdeploy), NOT config.yml
          # Example in superdeploy marker file:
          #
          # hooks:
          #   after_deploy:
          #     - npx prisma migrate deploy  # ‚úÖ Safe: idempotent
          #     - npm run cache:clear        # ‚úÖ Safe: always OK
          #     - npm run db:seed            # ‚ùå NEVER: duplicates data!
          #
          # ‚ö†Ô∏è  IMPORTANT RULES:
          # 1. Migrations should be IDEMPOTENT (safe to run multiple times)
          # 2. NEVER auto-run data seeding (causes duplicates)
          # 3. Only run operations that are safe on every deploy
          # 4. For manual tasks, use: superdeploy <project>:run <app> "<command>"

          MARKER_FILE="{% raw %}${{ github.workspace }}{% endraw %}/superdeploy"

          if [ ! -f "$MARKER_FILE" ]; then
            echo "‚è≠Ô∏è  No marker file, skipping hooks"
            exit 0
          fi

          APP_NAME="{% raw %}${{ steps.config.outputs.app }}{% endraw %}"
          PROJECT_NAME="{% raw %}${{ steps.config.outputs.project }}{% endraw %}"

          python3 - "$MARKER_FILE" <<'PYEOF' > /tmp/hooks.txt
          import yaml
          import sys

          try:
              with open(sys.argv[1]) as f:
                  marker = yaml.safe_load(f)
              hooks = marker.get('hooks', {}).get('after_deploy', [])
              for cmd in hooks:
                  print(cmd)
          except:
              pass
          PYEOF

          if [ ! -s /tmp/hooks.txt ]; then
            echo "‚è≠Ô∏è  No post-deployment hooks configured"
            exit 0
          fi

          echo "üîß Running post-deployment hooks..."
          cd /opt/superdeploy/projects/${PROJECT_NAME}/compose

          HOOK_SERVICE=$(grep "^  ${APP_NAME}-\(web\|release\)" docker-compose.yml | head -1 | cut -d: -f1 | xargs)

          if [ -z "$HOOK_SERVICE" ]; then
            HOOK_SERVICE=$(grep "^  ${APP_NAME}-" docker-compose.yml | head -1 | cut -d: -f1 | xargs)
          fi

          echo "üìç Running hooks on service: $HOOK_SERVICE"

          FAILED=0
          while IFS= read -r cmd; do
            if [ -n "$cmd" ]; then
              echo "‚ñ∂ Running: $cmd"
              if ! docker compose exec -T $HOOK_SERVICE sh -c "$cmd"; then
                echo "‚ö†Ô∏è  Hook failed: $cmd"
                FAILED=1
              fi
            fi
          done < /tmp/hooks.txt

          if [ $FAILED -eq 1 ]; then
            echo "‚ùå Post-deployment hooks failed"
            exit 1
          fi

          echo "‚úÖ Post-deployment hooks completed"
