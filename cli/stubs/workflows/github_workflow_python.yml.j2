name: Deploy to {{ project }}

on:
  push:
    branches: [production, staging]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      project: {% raw %}${{ steps.config.outputs.project }}{% endraw %}
      app: {% raw %}${{ steps.config.outputs.app }}{% endraw %}
      vm_role: {% raw %}${{ steps.config.outputs.vm_role }}{% endraw %}
    
    steps:
      - name: Checkout {{ app_name }} repository
        uses: actions/checkout@v4
        with:
          path: {{ app_name }}
      
      - name: Checkout commons models (shared workspace)
        uses: actions/checkout@v4
        with:
          repository: {{ repo_org }}/commons
          token: {% raw %}${{ secrets.PRIVATE_REPO_TOKEN }}{% endraw %}
          path: commons
      
      - name: Read app configuration
        working-directory: {{ app_name }}
        id: config
        run: |
          PROJECT=$(grep "^project:" .superdeploy | cut -d: -f2 | xargs)
          APP=$(grep "^app:" .superdeploy | cut -d: -f2 | xargs)
          VM_ROLE=$(grep "^vm:" .superdeploy | cut -d: -f2 | xargs)
          echo "project=$PROJECT" >> $GITHUB_OUTPUT
          echo "app=$APP" >> $GITHUB_OUTPUT
          echo "vm_role=$VM_ROLE" >> $GITHUB_OUTPUT
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: {% raw %}${{ secrets.DOCKER_USERNAME }}{% endraw %}
          password: {% raw %}${{ secrets.DOCKER_TOKEN }}{% endraw %}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./{{ app_name }}/Dockerfile
          push: true
          tags: |
            {% raw %}${{ secrets.DOCKER_ORG }}{% endraw %}/{% raw %}${{ steps.config.outputs.app }}{% endraw %}:latest
            {% raw %}${{ secrets.DOCKER_ORG }}{% endraw %}/{% raw %}${{ steps.config.outputs.app }}{% endraw %}:{% raw %}${{ github.sha }}{% endraw %}
          cache-from: type=registry,ref={% raw %}${{ secrets.DOCKER_ORG }}{% endraw %}/{% raw %}${{ steps.config.outputs.app }}{% endraw %}:buildcache
          cache-to: type=registry,ref={% raw %}${{ secrets.DOCKER_ORG }}{% endraw %}/{% raw %}${{ steps.config.outputs.app }}{% endraw %}:buildcache,mode=max

  deploy:
    needs: build
    environment: {% raw %}${{ github.ref_name }}{% endraw %}
    runs-on: 
      - self-hosted
      - superdeploy
      - {% raw %}${{ needs.build.outputs.project }}{% endraw %}
      - {% raw %}${{ needs.build.outputs.vm_role }}{% endraw %}
    
    steps:
      - name: Validate runner
        run: |
          echo "ðŸ” Validating deployment environment..."
          
          if [ ! -f /opt/superdeploy/.project ]; then
            echo "âŒ ERROR: /opt/superdeploy/.project not found!"
            exit 1
          fi
          
          RUNNER_PROJECT=$(cat /opt/superdeploy/.project)
          if [ "$RUNNER_PROJECT" != "{% raw %}${{ needs.build.outputs.project }}{% endraw %}" ]; then
            echo "âŒ ERROR: Wrong project! Expected {% raw %}${{ needs.build.outputs.project }}{% endraw %}, got $RUNNER_PROJECT"
            exit 1
          fi
          
          echo "âœ… Correct VM for project: $RUNNER_PROJECT"
      
      - name: Create .env from merged secrets
        run: |
          APP_NAME="{% raw %}${{ needs.build.outputs.app }}{% endraw %}"
          ENV_DIR="/opt/superdeploy/projects/{% raw %}${{ needs.build.outputs.project }}{% endraw %}/data/$APP_NAME"
          
          echo "ðŸ“ Creating .env from ${APP_NAME^^}_ENV_JSON..."

          # GitHub Actions cannot dynamically access secrets
          # The secret is created by: superdeploy sync (merges app .env + secrets.yml)
          case "$APP_NAME" in
            {{ app }})
{{ secret_var_line }}
              ;;
            *)
              echo "âŒ App '$APP_NAME' not configured in workflow"
              exit 1
              ;;
          esac

          # Convert JSON to .env format
          echo "$SECRET_VALUE" | jq -r 'to_entries[] | "\(.key)=\(.value)"' > /tmp/final.env
          
          # Write to VM directory
          sudo mkdir -p "$ENV_DIR"
          sudo cp /tmp/final.env "$ENV_DIR/.env"
          sudo chown superdeploy:superdeploy "$ENV_DIR/.env"
          sudo chmod 600 "$ENV_DIR/.env"
          
          echo "âœ… Environment file created at $ENV_DIR/.env"
          echo "ðŸ“Š Total variables: $(wc -l < "$ENV_DIR/.env")"
      
      - name: Deploy application (blue-green zero-downtime)
        run: |
          cd /opt/superdeploy/projects/{% raw %}${{ needs.build.outputs.project }}{% endraw %}/compose
          
          # Check if this specific service exists in docker-compose.yml
          if ! grep -q "^  {% raw %}${{ needs.build.outputs.app }}{% endraw %}:" docker-compose.yml; then
            echo "â­ï¸  Skipping: App not configured on this VM"
            exit 0
          fi
          
          # Create empty .env files for other apps to prevent docker-compose errors
          for app_dir in ../data/*/; do
            if [ -d "$app_dir" ]; then
              app_name=$(basename "$app_dir")
              env_file="../data/$app_name/.env"
              if [ ! -f "$env_file" ]; then
                echo "# Placeholder .env for $app_name" > "$env_file"
                echo "ðŸ“ Created placeholder .env for $app_name"
              fi
            fi
          done
          
          CONTAINER_NAME="{% raw %}${{ needs.build.outputs.project }}{% endraw %}_{% raw %}${{ needs.build.outputs.app }}{% endraw %}"
          BACKUP_CONTAINER="${CONTAINER_NAME}_backup_$$"
          
          echo "ðŸš€ Starting blue-green deployment..."
          
          # Pull new image first
          echo "ðŸ“¦ Step 1/5: Pulling new image..."
          docker compose pull {% raw %}${{ needs.build.outputs.app }}{% endraw %}
          
          # Check if container exists
          if docker ps -a --format '{% raw %}{{.Names}}{% endraw %}' | grep -q "^${CONTAINER_NAME}$"; then
            echo "ðŸ’¾ Step 2/5: Backing up current container (blue)..."
            docker rename $CONTAINER_NAME $BACKUP_CONTAINER 2>/dev/null || true
            
            echo "ðŸš€ Step 3/5: Starting new container (green)..."
            docker compose up -d {% raw %}${{ needs.build.outputs.app }}{% endraw %}
            
            echo "â³ Step 4/5: Health check (30s timeout)..."
            # Wait for container to be running and healthy
            TIMEOUT=30
            ELAPSED=0
            while [ $ELAPSED -lt $TIMEOUT ]; do
              STATUS=$(docker inspect -f '{% raw %}{{.State.Status}}{% endraw %}' $CONTAINER_NAME 2>/dev/null || echo "not_found")
              HEALTH=$(docker inspect -f '{% raw %}{{.State.Health.Status}}{% endraw %}' $CONTAINER_NAME 2>/dev/null || echo "none")
              
              if [ "$STATUS" = "running" ]; then
                if [ "$HEALTH" = "healthy" ] || [ "$HEALTH" = "none" ]; then
                  echo "âœ… New container healthy!"
                  break
                fi
              fi
              
              sleep 2
              ELAPSED=$((ELAPSED + 2))
              echo "   Waiting... ${ELAPSED}s/${TIMEOUT}s (Status: $STATUS, Health: $HEALTH)"
            done
            
            # Final check
            STATUS=$(docker inspect -f '{% raw %}{{.State.Status}}{% endraw %}' $CONTAINER_NAME 2>/dev/null || echo "not_found")
            HEALTH=$(docker inspect -f '{% raw %}{{.State.Health.Status}}{% endraw %}' $CONTAINER_NAME 2>/dev/null || echo "none")
            
            if [ "$STATUS" = "running" ] && ([ "$HEALTH" = "healthy" ] || [ "$HEALTH" = "none" ]); then
              echo "âœ… Step 5/5: Deployment successful, removing old container..."
              docker stop $BACKUP_CONTAINER 2>/dev/null || true
              docker rm $BACKUP_CONTAINER 2>/dev/null || true
              echo "âœ… Blue-green deployment complete!"
              echo "   Old (blue): Removed"
              echo "   New (green): Running"
            else
              echo "âŒ New container failed health check!"
              echo "   Status: $STATUS"
              echo "   Health: $HEALTH"
              echo ""
              echo "ðŸ”„ Performing automatic rollback..."
              
              # Stop failed new container
              docker stop $CONTAINER_NAME 2>/dev/null || true
              docker rm $CONTAINER_NAME 2>/dev/null || true
              
              # Restore backup (blue)
              docker rename $BACKUP_CONTAINER $CONTAINER_NAME
              docker start $CONTAINER_NAME
              
              echo "âœ… Rollback complete - old version restored"
              echo ""
              echo "ðŸ“‹ Failed container logs:"
              docker logs $BACKUP_CONTAINER --tail 50 2>/dev/null || true
              
              exit 1
            fi
          else
            echo "ðŸ“¦ Step 2/5: Fresh deployment (no existing container)..."
            echo "ðŸš€ Step 3/5: Starting container..."
            docker compose up -d {% raw %}${{ needs.build.outputs.app }}{% endraw %}
            
            echo "â³ Step 4/5: Health check..."
            sleep 10
            
            STATUS=$(docker inspect -f '{% raw %}{{.State.Status}}{% endraw %}' $CONTAINER_NAME 2>/dev/null || echo "not_found")
            
            if [ "$STATUS" = "running" ]; then
              echo "âœ… Step 5/5: Deployment successful!"
            else
              echo "âŒ Container failed to start"
              docker logs $CONTAINER_NAME --tail 50
              exit 1
            fi
          fi
          
          # Cleanup old images
          docker image prune -f >/dev/null 2>&1 || true
      
      - name: Calculate and update version
        run: |
          PROJECT_DIR="/opt/superdeploy/projects/{% raw %}${{ needs.build.outputs.project }}{% endraw %}"
          VERSION_FILE="$PROJECT_DIR/versions.json"
          APP_NAME="{% raw %}${{ needs.build.outputs.app }}{% endraw %}"
          
          # Initialize versions.json if it doesn't exist
          sudo mkdir -p "$PROJECT_DIR"
          if [ ! -f "$VERSION_FILE" ]; then
            echo "{}" | sudo tee "$VERSION_FILE" > /dev/null
            sudo chown superdeploy:superdeploy "$VERSION_FILE"
            sudo chmod 644 "$VERSION_FILE"
          fi
          
          # Get current version for this app
          CURRENT_VERSION=$(sudo cat "$VERSION_FILE" | jq -r --arg app "$APP_NAME" '.[$app].version // "0.0.0"')
          echo "Current version: $CURRENT_VERSION"
          
          # Determine version bump type from commit message
          COMMIT_MSG="{% raw %}${{ github.event.head_commit.message }}{% endraw %}"
          
          if echo "$COMMIT_MSG" | grep -qiE '^\[major\]|^breaking:'; then
            BUMP_TYPE="major"
          elif echo "$COMMIT_MSG" | grep -qiE '^\[minor\]|^feat:'; then
            BUMP_TYPE="minor"
          else
            BUMP_TYPE="patch"
          fi
          
          echo "Bump type: $BUMP_TYPE"
          
          # Parse and increment version
          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"
          
          case $BUMP_TYPE in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac
          
          NEW_VERSION="$major.$minor.$patch"
          DEPLOYED_AT=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo "New version: $NEW_VERSION"
          echo "ðŸ“Œ Updating version: $APP_NAME v$NEW_VERSION"
          
          # Update version for this app
          UPDATED_JSON=$(sudo cat "$VERSION_FILE" | jq --arg app "$APP_NAME" --arg ver "$NEW_VERSION" --arg deployed "$DEPLOYED_AT" --arg sha "{% raw %}${{ github.sha }}{% endraw %}" --arg actor "{% raw %}${{ github.actor }}{% endraw %}" --arg branch "{% raw %}${{ github.ref_name }}{% endraw %}" '
            .[$app] = {
              "version": $ver,
              "deployed_at": $deployed,
              "git_sha": $sha,
              "deployed_by": $actor,
              "branch": $branch
            }
          ')
          
          echo "$UPDATED_JSON" | sudo tee "$VERSION_FILE" > /dev/null
          sudo chown superdeploy:superdeploy "$VERSION_FILE"
          sudo chmod 644 "$VERSION_FILE"
          
          echo "âœ… Version tracked: v$NEW_VERSION"
      
      - name: Run deployment hooks
        run: |
          cd /opt/superdeploy/projects/{% raw %}${{ needs.build.outputs.project }}{% endraw %}
          
          if [ ! -f config.yml ]; then
            echo "â­ï¸  No config.yml found, skipping hooks"
            exit 0
          fi
          
          APP_NAME="{% raw %}${{ needs.build.outputs.app }}{% endraw %}"
          
          cat > /tmp/read_hooks.py <<'PYEOF'
          import yaml
          import sys
          import os
          
          try:
              with open('config.yml') as f:
                  config = yaml.safe_load(f)
              app_name = os.environ.get('APP_NAME', '')
              hooks = config.get('apps', {}).get(app_name, {}).get('hooks', {})
              after_deploy = hooks.get('after_deploy', [])
              if after_deploy:
                  for cmd in after_deploy:
                      print(cmd)
          except Exception:
              sys.exit(0)
          PYEOF
          
          HOOKS=$(APP_NAME="$APP_NAME" python3 /tmp/read_hooks.py)
          
          if [ -z "$HOOKS" ]; then
            echo "â­ï¸  No post-deployment hooks configured for {% raw %}${{ needs.build.outputs.app }}{% endraw %}"
            exit 0
          fi
          
          echo "ðŸ”§ Running post-deployment hooks for {% raw %}${{ needs.build.outputs.app }}{% endraw %}..."
          cd compose
          
          FAILED=0
          echo "$HOOKS" | while IFS= read -r cmd; do
            if [ -n "$cmd" ]; then
              echo "â–¶ Running: $cmd"
              if ! docker compose exec -T {% raw %}${{ needs.build.outputs.app }}{% endraw %} $cmd; then
                echo "âš ï¸  Hook failed: $cmd"
                FAILED=1
              fi
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo "âŒ Post-deployment hooks failed"
            exit 1
          fi
          
          echo "âœ… Post-deployment hooks completed"


