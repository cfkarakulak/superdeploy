name: Deploy to {{ project }}

on:
  push:
    branches: [production, staging]
  workflow_dispatch:

jobs:
  # üéØ PREPARE: Checkout repository and upload artifact
  # ‚ÑπÔ∏è  If you need to checkout additional repos (like commons), add steps here manually
  prepare:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout {{ app_name }} repository
        uses: actions/checkout@v4
        with:
          token: {% raw %}${{ secrets.REPOSITORY_TOKEN }}{% endraw %}
          path: {{ app_name }}

      # ‚ÑπÔ∏è  Add additional checkout steps here if needed, e.g.:
      # - name: Checkout commons (shared)
      #   uses: actions/checkout@v4
      #   with:
      #     repository: {{ repo_org }}/commons
      #     token: {% raw %}${{ secrets.REPOSITORY_TOKEN }}{% endraw %}
      #     path: commons

      - name: Upload workspace as artifact
        uses: actions/upload-artifact@v4
        with:
          name: workspace
          path: {{ app_name }}/
          retention-days: 1

  # üì¶ BUILD: Reusable workflow for Docker build
  build:
    needs: prepare
    uses: cfkarakulak/superdeploy/.github/workflows/deploy-app-build.yml@master
    with:
      docker_org: {{ docker_org }}
      docker_username_var: DOCKER_USERNAME
    secrets:
      REPOSITORY_TOKEN: {% raw %}${{ secrets.REPOSITORY_TOKEN }}{% endraw %}
      DOCKER_TOKEN: {% raw %}${{ secrets.DOCKER_TOKEN }}{% endraw %}

  # üöÄ DEPLOY: Self-hosted runner deployment
  # Project label is hardcoded from template (GitHub masks dynamic outputs as secrets)
  deploy:
    needs: build
    environment: {% raw %}${{ github.ref_name }}{% endraw %}
    runs-on:
      - self-hosted
      - superdeploy
      - {{ project }}
      - {% raw %}${{ needs.build.outputs.vm_role }}{% endraw %}

    steps:
      - name: Download workspace artifact
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: {% raw %}${{ github.workspace }}{% endraw %}

      - name: Read app configuration from marker
        id: config
        run: |
          MARKER_FILE=$(find "{% raw %}$GITHUB_WORKSPACE{% endraw %}" -name "superdeploy" -type f | head -1)
          if [ ! -f "$MARKER_FILE" ]; then
            echo "‚ùå ERROR: Marker file not found!"
            exit 1
          fi
          
          PROJECT=$(grep "^project:" "$MARKER_FILE" | cut -d: -f2 | xargs)
          APP=$(grep "^app:" "$MARKER_FILE" | cut -d: -f2 | xargs)
          
          echo "project=$PROJECT" >> {% raw %}$GITHUB_OUTPUT{% endraw %}
          echo "app=$APP" >> {% raw %}$GITHUB_OUTPUT{% endraw %}
          echo "‚úÖ Config: project=$PROJECT, app=$APP"

      - name: Validate runner
        run: |
          RUNNER_PROJECT=$(cat /opt/superdeploy/.project)
          if [ "$RUNNER_PROJECT" != "{% raw %}${{ steps.config.outputs.project }}{% endraw %}" ]; then
            echo "‚ùå ERROR: Wrong project! Expected {% raw %}${{ steps.config.outputs.project }}{% endraw %}, got $RUNNER_PROJECT"
            exit 1
          fi
          echo "‚úÖ Correct VM for project: $RUNNER_PROJECT"

      - name: Create .env from GitHub Environment Secrets
        env:
          SECRETS_JSON: {% raw %}${{ toJSON(secrets) }}{% endraw %}
        run: |
          APP_NAME="{% raw %}${{ steps.config.outputs.app }}{% endraw %}"
          PROJECT="{% raw %}${{ steps.config.outputs.project }}{% endraw %}"
          ENV_DIR="/opt/superdeploy/projects/$PROJECT/data/$APP_NAME"
          
          echo "üìù Creating .env from GitHub secrets..."
          sudo mkdir -p "$ENV_DIR"
          
          echo "$SECRETS_JSON" | jq -r 'to_entries[] | "\(.key)=\(.value)"' > /tmp/final.env
          
          sudo cp /tmp/final.env "$ENV_DIR/.env"
          sudo chown superdeploy:superdeploy "$ENV_DIR/.env"
          sudo chmod 600 "$ENV_DIR/.env"
          
          echo "‚úÖ Environment file created"
          echo "üìä Total variables: $(wc -l < "$ENV_DIR/.env")"

      - name: Update docker-compose.yml from marker
        run: |
          APP_NAME="{% raw %}${{ steps.config.outputs.app }}{% endraw %}"
          PROJECT="{% raw %}${{ steps.config.outputs.project }}{% endraw %}"
          COMPOSE_FILE="/opt/superdeploy/projects/$PROJECT/compose/docker-compose.yml"
          MARKER_FILE=$(find "{% raw %}$GITHUB_WORKSPACE{% endraw %}" -name "superdeploy" -type f | head -1)
          
          sudo python3 - "$APP_NAME" "$COMPOSE_FILE" "$MARKER_FILE" "$PROJECT" << 'PYSCRIPT'
          import yaml
          import sys
          
          app_name = sys.argv[1]
          compose_file = sys.argv[2]
          marker_file = sys.argv[3]
          project_name = sys.argv[4]
          
          try:
              with open(marker_file, 'r') as f:
                  marker = yaml.safe_load(f)
          
              with open(compose_file, 'r') as f:
                  compose = yaml.safe_load(f)
          
              if compose.get('services') is None:
                  compose['services'] = {}
          
              processes = marker.get('processes', {})
              if not processes:
                  print(f"WARNING: No processes found in marker file")
                  sys.exit(0)
          
              for process_name, process_config in processes.items():
                  service_name = f"{app_name}-{process_name}"
                  replicas = process_config.get('replicas', 1)
                  port = process_config.get('port')
                  command = process_config.get('command', '')
                  
                  if service_name not in compose['services']:
                      compose['services'][service_name] = {
                          'image': f"docker.io/{{ docker_org }}/{app_name}:latest",
                          'command': command,
                          'env_file': f"/opt/superdeploy/projects/{project_name}/data/{app_name}/.env",
                          'volumes': [
                              f"/opt/superdeploy/projects/{project_name}/data/{app_name}:/app/data",
                              f"/opt/superdeploy/projects/{project_name}/logs/{app_name}:/app/logs"
                          ],
                          'networks': {
                              f"{project_name}-network": {
                                  'aliases': [f"{app_name}-{process_name}"]
                              }
                          },
                          'deploy': {
                              'mode': 'replicated',
                              'replicas': replicas,
                              'restart_policy': {
                                  'condition': 'on-failure',
                                  'delay': '5s',
                                  'max_attempts': 3
                              }
                          }
                      }
                      
                      if port:
                          compose['services'][service_name]['healthcheck'] = {
                              'test': ['CMD', 'curl', f'http://localhost:{port}/health'],
                              'interval': '30s',
                              'timeout': '10s',
                              'retries': 3,
                              'start_period': '40s'
                          }
                          compose['services'][service_name]['ports'] = [f"{port}:{port}"]
                      else:
                          compose['services'][service_name]['healthcheck'] = {'disable': True}
                      
                      print(f"‚úÖ Created {service_name}")
                  else:
                      service = compose['services'][service_name]
                      service['command'] = command
                      if 'deploy' not in service:
                          service['deploy'] = {}
                      service['deploy']['replicas'] = replicas
                      print(f"‚úÖ Updated {service_name}")
              
              with open(compose_file, 'w') as f:
                  yaml.dump(compose, f, default_flow_style=False, sort_keys=False)
              
              print(f"‚úÖ docker-compose.yml updated for {app_name}")
              
          except Exception as e:
              print(f"Failed to update compose: {e}")
              sys.exit(0)
          PYSCRIPT

      - name: Deploy application
        run: |
          cd /opt/superdeploy/projects/{% raw %}${{ steps.config.outputs.project }}{% endraw %}/compose
          APP_NAME="{% raw %}${{ steps.config.outputs.app }}{% endraw %}"
          
          # Create placeholder .env files
          for app_dir in ../data/*/; do
            if [ -d "$app_dir" ]; then
              env_file="../data/$(basename "$app_dir")/.env"
              [ ! -f "$env_file" ] && echo "# Placeholder" > "$env_file"
            fi
          done
          
          SERVICES=$(grep "^  ${APP_NAME}-" docker-compose.yml | cut -d: -f1 | xargs)
          echo "üöÄ Deploying services: $SERVICES"
          
          docker pull {% raw %}${{ vars.DOCKER_ORG }}{% endraw %}/${APP_NAME}:latest
          
          for service in $SERVICES; do
            docker compose up -d --no-deps $service
          done
          
          sleep 10
          
          RUNNING=0
          for service in $SERVICES; do
            COUNT=$(docker compose ps $service --status running 2>/dev/null | grep -c "$service" || echo 0)
            RUNNING=$((RUNNING + COUNT))
          done
          
          if [ "$RUNNING" -ge "1" ]; then
            echo "‚úÖ Deployment successful! ($RUNNING replicas running)"
          else
            echo "‚ùå Deployment failed"
            docker compose logs $SERVICES --tail 20
            exit 1
          fi
          
          docker image prune -f >/dev/null 2>&1 || true

      - name: Update version
        run: |
          PROJECT_DIR="/opt/superdeploy/projects/{% raw %}${{ steps.config.outputs.project }}{% endraw %}"
          RELEASES_FILE="$PROJECT_DIR/releases.json"
          APP_NAME="{% raw %}${{ steps.config.outputs.app }}{% endraw %}"
          
          sudo mkdir -p "$PROJECT_DIR"
          [ ! -f "$RELEASES_FILE" ] && echo "{}" | sudo tee "$RELEASES_FILE" > /dev/null
          
          CURRENT_VERSION=$(sudo cat "$RELEASES_FILE" | jq -r --arg app "$APP_NAME" '.[$app][-1].version // "0.0.0"')
          
          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"
          patch=$((patch + 1))
          NEW_VERSION="$major.$minor.$patch"
          
          NEW_RELEASE=$(jq -n --arg ver "$NEW_VERSION" --arg sha "{% raw %}${{ github.sha }}{% endraw %}" --arg actor "{% raw %}${{ github.actor }}{% endraw %}" '{
            version: $ver,
            deployed_at: (now | strftime("%Y-%m-%dT%H:%M:%SZ")),
            git_sha: $sha,
            deployed_by: $actor
          }')
          
          UPDATED=$(sudo cat "$RELEASES_FILE" | jq --argjson release "$NEW_RELEASE" --arg app "$APP_NAME" '.[$app] = ((.[$app] // []) + [$release])[-5:]')
          echo "$UPDATED" | sudo tee "$RELEASES_FILE" > /dev/null
          
          echo "üì¶ Version: v$NEW_VERSION"

      - name: Run post-deployment hooks
        run: |
          MARKER_FILE=$(find "{% raw %}$GITHUB_WORKSPACE{% endraw %}" -name "superdeploy" -type f | head -1)
          
          if [ ! -f "$MARKER_FILE" ]; then
            echo "‚è≠ No marker file, skipping hooks"
            exit 0
          fi
          
          APP_NAME="{% raw %}${{ steps.config.outputs.app }}{% endraw %}"
          PROJECT_NAME="{% raw %}${{ steps.config.outputs.project }}{% endraw %}"
          
          python3 - "$MARKER_FILE" <<'PYEOF' > /tmp/hooks.txt
          import yaml
          import sys
          
          try:
              with open(sys.argv[1]) as f:
                  marker = yaml.safe_load(f)
              hooks = marker.get('hooks', {}).get('after_deploy', [])
              for cmd in hooks:
                  print(cmd)
          except:
              pass
          PYEOF
          
          if [ ! -s /tmp/hooks.txt ]; then
            echo "‚è≠ No post-deployment hooks configured"
            exit 0
          fi
          
          echo "Running post-deployment hooks..."
          cd /opt/superdeploy/projects/${PROJECT_NAME}/compose
          
          HOOK_SERVICE=$(grep "^  ${APP_NAME}-\(web\|release\)" docker-compose.yml | head -1 | cut -d: -f1 | xargs)
          [ -z "$HOOK_SERVICE" ] && HOOK_SERVICE=$(grep "^  ${APP_NAME}-" docker-compose.yml | head -1 | cut -d: -f1 | xargs)
          
          echo "Running hooks on service: $HOOK_SERVICE"
          
          FAILED=0
          while IFS= read -r cmd; do
            if [ -n "$cmd" ]; then
              echo "Running: $cmd"
              if ! docker compose exec -T $HOOK_SERVICE sh -c "$cmd"; then
                echo "Hook failed: $cmd"
                FAILED=1
              fi
            fi
          done < /tmp/hooks.txt
          
          [ $FAILED -eq 1 ] && exit 1
          echo "‚úÖ Post-deployment hooks completed"
